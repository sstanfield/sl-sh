<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slosh Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Slosh Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="slosh-containercomplex-data-types"><a class="header" href="#slosh-containercomplex-data-types">slosh container/complex data types</a></h1>
<p>TODO</p>
<ul>
<li>char/char literal</li>
<li>bytes</li>
<li>vec</li>
<li>numbers / number literals</li>
<li>boolean literals</li>
</ul>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>A string.  Strings in slosh are UTF8 encoded and are composed of chars that are
UTF grapheme clusters.  Because of the encoding strings can be indexed but they
must be traversed to find an index (i.e. they are indexed by 'chars' not bytes).</p>
<p>Read only string constants can be created with double quotes in the Reader.
For instance: (def str-const "Some String Const")</p>
<p>A mutable string can be created with the 'str' form, for instance:
(def string (str "Some val: " val))</p>
<p>Characters at index can be accessed with dot notation (see Vector).</p>
<p>Other string functions:</p>
<ul>
<li>str: concats all the values provided (as strings) to produce a new string (mutable)</li>
<li>str-replace</li>
<li>str-trim</li>
<li>str-trim!</li>
<li>str-contains</li>
<li>str-push!</li>
<li>str-map</li>
<li>str-empty?</li>
<li>str-starts-with</li>
<li>str-split</li>
<li>char-whitespace?</li>
</ul>
<h2 id="vector"><a class="header" href="#vector">Vector</a></h2>
<p>A vector (dynamic array) of values.  Typically a vector will be created with the
'[' reader macro (expands to (vec ...)) for instance:
(def vector[1 2 3])
Vectors can be indexed with 'dot' notation (dot is a reader macro that expends
to a (get x index) for x.index.  For example:
(let (v [1 2 3])
(prn v.0 ", " v.1 ", " v.2))
Dot notation can also be used with set! to set elements:
(let (v [1 2 3])
(set! v.0 10)
(set! v.1 20)
(set! v.2 30)
(prn v.0 ", " v.1 ", " v.2))</p>
<p>Other vector functions:</p>
<ul>
<li>vec: longform for '[]' syntax, prefer using brackets</li>
<li>make-vec: takes a capacity and default value, makes a vector of that size with all values set to default</li>
<li>vec-push!: destructive, pushes a new value to the end of a vec (increases len by one)</li>
<li>vec-pop!: destructive, pops the last value from a vector and returns it (decreases vector len by one)</li>
<li>vec-slice: takes a vector, start index and optional end index (defaults to end of vector), returns a new vec of elements start (inclusive) end (exclusive)</li>
</ul>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>A map of key/value pairs.  Use the '{' reader macro to create a hashmap:
(def hm {:x 1, :y 2, :z 3})
Use dot notation (see vectors) to access and set keys:
(let (hm {:x 1, :y 2, :z 3})
(set! hm.:x 10)
(set! hm.:y 20)
(set! hm.:z 30)
(prn hm.:x ", " hm.:y ", " hm.:z))</p>
<p>Other hashmap function:</p>
<ul>
<li>make-hash: longform for '{}' reader macro, prefer '{}'</li>
</ul>
<h2 id="pairconscelllist"><a class="header" href="#pairconscelllist">Pair/ConsCell/List</a></h2>
<p>This is a traditional Lisp conscell data type, pair of values (car, cdr).  It can
be used to create a linked list of values.</p>
<p>Other Pair function:</p>
<ul>
<li>car</li>
<li>cdr</li>
<li>list</li>
<li>list-append</li>
<li>cons</li>
<li>xar!</li>
<li>xdr!</li>
</ul>
<h2 id="common-functions"><a class="header" href="#common-functions">Common functions</a></h2>
<p>These should all work on any of the containers.</p>
<ul>
<li>len: return the length of the container</li>
<li>clear!: destructive form to remove all elements from the container</li>
<li>set!: with dot notation to set an element of a container (see Vector and HashMap)</li>
<li>dot notation: this is a reader macro the expends to (get val index) for val.index</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality"><a class="header" href="#equality">Equality</a></h1>
<p>The most common way to test equality is with <code>=</code>
For numeric equality (IEEE) use <code>==</code>
For bytewise equality use <code>identical?</code></p>
<p>The behavior and names are based on Clojure's implementation. Read their docs here: https://clojure.org/guides/equality
Also check out <code>slosh/tests/equality.slosh</code> for some examples.</p>
<ul>
<li>
<p><code>=</code></p>
<ul>
<li>
<p><code>(= 2 0x2)</code> is <code>true</code> (comparing an int to a byte)</p>
</li>
<li>
<p><code>(= 2 2.0)</code> is <code>false</code> (comparing an int to a float)</p>
</li>
<li>
<p><code>(= 0.0 -0.0)</code> is <code>true</code></p>
</li>
<li>
<p><code>(= NaN NaN)</code> is <code>false</code></p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>equal</code> mapped to the name <code>=</code>.</p>
</li>
<li>
<p><code>compile.rs</code> matches on <code>env.specials().equal</code> and generates opcode <code>EQUAL</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>EQUAL</code> to function <code>is_equal</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_equal</code> converts each arg to a <code>Value</code> (in case it needs to be dereferenced) and calls <code>is_equal_pair</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_equal_pair</code> does a complex test for equality</p>
<ul>
<li>check if both args are Byte or Int and if so, converts both to <code>i64</code> with <code>Value::get_int</code> and compares with
rust native <code>==</code></li>
<li>check if both args are numbers (Byte, Int, or Float) and if so, converts both to <code>f64</code> with <code>Value::get_float</code>
and compares with rust native <code>==</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>==</code></p>
<ul>
<li>
<p><code>(== 1 1.0)</code> is <code>true</code> (comparing an int to a float)</p>
</li>
<li>
<p><code>(== 0.0 -0.0)</code> is <code>true</code></p>
</li>
<li>
<p><code>(== NaN NaN)</code> is <code>false</code></p>
</li>
<li>
<p>returns true whenever <code>=</code> does, but also returns true for numbers that are numerically equal</p>
</li>
<li>
<p>when comparing two floats, converts two both to <code>f64</code> and compares with native f64 <code>==</code></p>
</li>
<li>
<p>does not use F56::PartialEq implementation</p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>numeq</code> mapped to the name <code>==</code>.</p>
</li>
<li>
<p><code>compile.rs</code> calls <code>compile_list</code> which calls <code>compile_special</code> which calls <code>compile_math</code> in <code>compile_math.rs</code></p>
</li>
<li>
<p><code>compile_math.rs</code> <code>compile_math</code> matches on <code>env.specials().numeq</code> and generates opcode <code>NUMEQ</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>NUMEQ</code> to function <code>compare_numeric</code> and passes a comparator <code>|a,b| a == b</code></p>
</li>
<li>
<p><code>macros.rs</code> <code>compare_numeric</code></p>
<ul>
<li>checks if either argument is a <code>Float</code> and if so, converts both to <code>f64</code> with <code>get_primitive_float</code> macro and
uses the comparator</li>
<li>checks if either argument is a <code>Int</code> and if so, converts both to <code>i64</code> with <code>get_primitive_int</code> macro and uses
the comparator</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>identical?</code></p>
<ul>
<li>
<p><code>(identical? 1 1)</code> is <code>true</code></p>
</li>
<li>
<p><code>(identical? 1 1.0)</code> is <code>false</code> (different types)</p>
</li>
<li>
<p><code>(identical? 0.0 -0.0)</code> is <code>false</code> (comparing floats with different bit patterns)</p>
</li>
<li>
<p><code>(identical? NaN NaN)</code> might be <code>true</code> or <code>false</code>. There are trillions of different bit patterns that represent
NaN in IEEE 754</p>
</li>
<li>
<p>is the only equality comparison that uses <code>Value::PartialEq</code> implementation which is always false for different
types of Values</p>
</li>
<li>
<p>using identical equality for floats causes problems with hashing.
<a href="https://github.com/sl-sh-dev/sl-sh/issues/125">#125</a>
identical equality is 'too strict' in that you probably expect that +0 and -0 should hash to the same thing, but
they don't
rendering hash tables</p>
</li>
<li>
<p><code>state.rs</code> defines special forms object with key <code>eq</code> mapped to the name <code>identical?</code>.</p>
</li>
<li>
<p><code>compile.rs</code> matches on <code>env.specials().eq</code> and generates opcode <code>EQ</code></p>
</li>
<li>
<p><code>exec_loop.rs</code> maps opcode <code>EQ</code> to function <code>is_identical</code></p>
</li>
<li>
<p><code>vm.rs</code> <code>is_identical</code> converts each arg to a <code>Value</code> (in case it needs to be dereferenced) and
compares <code>val1 == val2</code> which uses <code>Value::PartialEq</code> implementation</p>
</li>
</ul>
</li>
<li>
<p><code>assert-equal</code></p>
<ul>
<li>based on <code>=</code></li>
<li>is a macro defined in core.slosh which checks if the arguments are <code>=</code> and throws an error if they are not</li>
</ul>
</li>
<li>
<p><code>not=</code></p>
<ul>
<li>defined in <code>vm/core.slosh</code> as the negation of <code>=</code></li>
</ul>
</li>
<li>
<p><code>not==</code></p>
<ul>
<li>defined in <code>vm/core.slosh</code> as the negation of <code>==</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Namespaces are compiler bookkeeping for organizing global symbols.  When in a namespace then any symbols that are defined will have the current NAMESPACE:: prepended to the symbol.  When symbols are resolved the compiler will also try to prepend the current namespace first in order to find the symbol.</p>
<h2 id="entering-a-namespace"><a class="header" href="#entering-a-namespace">Entering a namespace</a></h2>
<p>From code use the 'with-ns' form.</p>
<pre><code class="language-slosh">(doc 'with-ns)

;; =&gt; "Usage: (with-ns SYMBOL sexp+)
;;    
;;    Create a namespace and compile sexp+ within it.  Restore the previous namespace when scope ends.
;;    THe symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: core
;;    
;;    Example:
;;    (with-ns test-with-ns
;;        (def ttf (fn () '(1 2 3)))
;;        (test::assert-equal '(1 2 3) (ttf))
;;        (test::assert-equal '(1 2 3) (test-out::ttf)))
;;    (test::assert-equal '(1 2 3) (test-out::ttf))
;;    "
</code></pre>
<p>From the top-level REPL you can use 'ns'.</p>
<pre><code class="language-slosh">(doc 'ns)

;; =&gt; "Usage: (ns SYMBOL)
;;    
;;    Changes to namespace.  This is "open-ended" change and is intended for use with
;;    the REPL prefer with-ns for scripts.
;;    The symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: core
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    "
</code></pre>
<p>This is an open-ended namespace change intended for the repl, prefer with-ns for a scoped namespace in code.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Other namespaces can be imported to allow its symbols to be accessed in a shorter form.  Use the 'import' form for this .</p>
<pre><code class="language-slosh">(doc 'import)

;; =&gt; "Usage: (import namespace [:as symbol])
;;    
;;    Will import a namespace.  Without an :as then all symbols in the namespace will become available in the current
;;    namespace as if local.  With [:as symbol] then all namespace symbols become available with symbol:: prepended.
;;    
;;    Section: core
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    (import testing)
;;    (test::assert-true x)
;;    (import testing :as t)
;;    (test::assert-true t::x)
;;    "
</code></pre>
<p>For instance using <code>(import iter)</code> will allow any symbols in the iter namespace to be used without prepending 'iter::'.  You can also use the <code>(import iter :as i)</code>, the :as form allows the namespace to be given a different name.  In this case the iter namespace could be replaced with 'i', (i::for ...) instead of (iter::for ...) for example.  Imports are resolved in the order they are compiled in case of conflict (i.e. the first import that resolves a symbol wins).  Imports are attached to the current namespace, changing namespaces will clear imports (note that 'with-ns' saves and restores the previous namespace with imports).</p>
<h2 id="loading-code"><a class="header" href="#loading-code">Loading code</a></h2>
<p>To load new code into your environment use load or run-script.</p>
<h3 id="load"><a class="header" href="#load">Load</a></h3>
<p>The load form should generally be preferred.  It will compile the code at compile time (vs runtime) and execute it at runtime.  This means:</p>
<ul>
<li>The path parameter has to be known at compile time: a string const, defined global or form that does not need local inputs.</li>
<li>Any symbols defined in the loaded code will be known to the compiler at compile time and available for use.</li>
</ul>
<pre><code class="language-slosh">(doc 'load)

;; =&gt; "Usage: (load path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).  The load special form executes at compile time.
;;    This means it's parameter must resolve at compile time.  Most of the time you will want to use
;;    this in conjunction with 'with-ns' to namespace the contents.
;;    Note: on it's own does nothing with namespaces.
;;    
;;    Section: core
;;    
;;    Example:
;;    (comp-time (def test-temp-file (get-temp-file)) nil)
;;    (defer (fs-rm test-temp-file))
;;    (let (tst-file (fopen test-temp-file :create))
;;        (defer (fclose tst-file))
;;        (fprn tst-file "(with-ns test-load")
;;        (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;    (load test-temp-file) ; put stuff in it's own namespace
;;    (test::assert-equal '(1 2 3) (test-load::test-fn))
;;    
;;    
;;    (with-ns test-out2
;;        (comp-time
;;            (def test-temp-file (get-temp-file))
;;            (let (tst-file (fopen test-temp-file :create))
;;                (defer (fclose tst-file))
;;                (fprn tst-file "(defn test-fn () '(1 2 3))"))
;;            nil)
;;        (defer (fs-rm test-temp-file))
;;        (load test-temp-file) ; put new stuff in current namespace
;;        (test::assert-equal '(1 2 3) (test-fn))
;;        (test::assert-equal '(1 2 3) (test-out2::test-fn)))
;;    "
</code></pre>
<h3 id="run-script"><a class="header" href="#run-script">Run Script</a></h3>
<p>The run-script form loads each form in the file, compiles and executes it at runtime.  This means:</p>
<ul>
<li>It can take any parameter since it is resolved at runtime.</li>
<li>Globals it defines will NOT be known until after it runs at runtime.</li>
</ul>
<pre><code class="language-slosh">(doc 'run-script)

;; =&gt; "Usage: (run-script path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).
;;    
;;    Section: scripting
;;    
;;    Example:
;;    (def test-load::test-fn)
;;    (with-temp-file (fn (tmp)
;;        (let (tst-file (fopen tmp :create))
;;            (defer (fclose tst-file))
;;            (fprn tst-file "(with-ns test-load")
;;            (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;        (run-script tmp)
;;        (test::assert-equal '(1 2 3) (test-load::test-fn))))
;;    "
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">ERRORS</a></h1>
<h2 id="error-type"><a class="header" href="#error-type">Error Type</a></h2>
<p>The error type consists of an identifying keyword and a data/payload value.  This
value is typically a string but can be any valid value.</p>
<p>(type [error]) returns :Error
The form (car [error]) returns the keyword identifying this error.
The form (cdr [error]) returns the data value for the error.
Note the use of car/cdr to pull apart an error even though it is not of the pair type.
Use (mk-err :[ID] value) to create an error type or (err :[ID] value) to "raise" an error (see below).</p>
<h2 id="raising-an-error"><a class="header" href="#raising-an-error">Raising an error</a></h2>
<p>Runtime errors will be "raised".  This means the program execution will halt and the debugger will be entered.  Currently this only allows examining the running state but will eventually include the ability to modify state and restart as other Lisps allow.  Code can raise an error with the err form, for instance (err :some-error-type "This is my error") will raise an error and interrupt the program.</p>
<p>Note, the (get-error FORM+) form can be used to programmatically return a raised error instead of breaking to the debugger.</p>
<h2 id="returning-an-error"><a class="header" href="#returning-an-error">Returning an error</a></h2>
<p>Code can return an error instead of breaking into the debugger.  Use the (mk-err :[ERROR ID] vallue) to create an error and then use it as any other value (return it from a function for instance).  This may be appropriate for a common error that does not warrent breaking to the debugger.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>See the docs string for:</p>
<ul>
<li>err</li>
<li>mk-err</li>
<li>err?</li>
<li>ok?</li>
<li>get-error</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sloshlisp-syntax-and-macros"><a class="header" href="#sloshlisp-syntax-and-macros">Slosh/Lisp syntax and macros</a></h1>
<p>The core unit of a Lisp is a form:</p>
<pre><code class="language-slosh">42

;; =&gt; 42
</code></pre>
<pre><code class="language-slosh">+

;; =&gt; #&lt;SpecialFn(+)&gt;
</code></pre>
<pre><code class="language-slosh">(list 1 2)

;; =&gt; (1 2)
</code></pre>
<pre><code class="language-slosh">;; The quote symbol means return the literal form after the character
;; This is identical to the form above.
'(1 2)

;; =&gt; (1 2)
</code></pre>
<p>are forms. All
lisp code is structured as a sequence of forms inside forms separated by whitespace.</p>
<p>Expressions are enclosed in parentheses and Lisp uses prefix notation to parse expressions.
A parenthesized expression is a list of forms: <code>(list 1 2 3 4)</code> where the first
form, the head, should generally be a function or a macro and dictates what the expression will do,
and the subsequent children are arguments to the head.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Single-line comments start with a <code>;</code> character and continue till the end of the line</p>
<pre><code class="language-slosh">; (prn "hello")
(prn "world")

;; =&gt; "world"
</code></pre>
<p>Multi-line comments start with the <code>#|</code> characters to start and ends with the sample symbols reversed <code>|#</code>.</p>
<pre><code class="language-slosh">#|
(prn "oh")
(prn "hello")
|#
(prn "world")

;; =&gt; "world"
</code></pre>
<p>Single forms can be commented out with <code>#;</code> characters. This directive tells the reader to discard the form.</p>
<pre><code class="language-slosh">#;(prn "oh")
#;(prn "hello")
(prn "world")

;; =&gt; "world"
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Any symbol that is used with <code>def</code> or <code>defn</code> can also bind documentation. Documentation
is multiline and is delimited with <code>#%</code> characters to start and ends with the same symbols reversed <code>%#</code>.</p>
<pre><code class="language-slosh">#%
Usage: (login SECRET)

Returns true if logged in false if not. Must use `SECRET`

Section: secrets

Example:
(assert-false (login "foo"))
%#
(defn login (secret)
    (if (= secret "helloworld")
        #t
        #f))


#%
Usage: (login SECRET)

Returns documentation for given symbol as map. Keyword is a documentation fragment
(usage, section, description, example) and value is text describing given fragment.

Section: secrets

Example:

(assert-false (login SECRET))
%#
(def SECRET "helloworld")
(prn (login SECRET))

;; =&gt; "true"
</code></pre>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Helper macros syntax exists like in other lips such as:
quote (<code>'</code>),
quasiquote (<code>`</code>),
unquote (<code>~</code>),
unquote-splice (<code>~@</code>),
macro, and
defmacro.</p>
<pre><code>(defmacro dotimes
    ;; This macro accepts times, some number, as well as some number of forms to be evaluated.
    (times &amp; body)

    ;; To avoid creating a variable name in the existing scope (gensym helps
    ;; with the creation of hygenic macros in slosh) is used and
    ;; the symbol i-name is assigned some random name.
    (let (i-name (gensym))

    ;; The quasiquote is used within the body of the macro to specify that all forms
    ;; inside the parentheses should have an implicit quote in front of them. This
    ;; way, by default, the macro will return an ast with the literal forms, as opposed to the
    ;; evaulauted forms; forms can be evaluated in the resultant ast with the unquote.

    `(let (~i-name 0)

        ;; i-iname and times are unquoted so they are evaluated ("escaping the
        ;; quasiquote") in the resultant ast returning numerical values instead
        ;; of symbols that evaluate to themselves.
        (while (&lt; ~i-name ~times)

            ;; Since body is a list, it utilizes the unquote-splice operator, to
            ;; expand each of its elements into the resultant ast, in the case
            ;; of dotimes `body` in intended to be some number of forms that
            ;; should be executed on each invocation.
            ~@body

            ;; because i-name is a symbol defined in the outer scope use unquote
            ;; so the resultant ast outputs `(inc! random-var-nmae)` rather than
            ;; (inc! i-name). `i-name` is not a symbol in scope in the resultant ast,
            ;; ~i-name evaluates to a symbol that is in scope in the resultant
            ;; ast.
            (inc! ~i-name)))))
</code></pre>
<p>NOTE:
The quasiquote is a quality of life macro helper, that obviates the need to
add a single quote to every list and every form in the body of your macro. It
is particularly useful in macros because often times many of the symbols you
want returned in a macro are the literal symbols you want in the output ast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Still figuring this out currently allows things like this (syntax will probably change):</p>
<p>Current iteration uses :&lt; (same as :0&lt;) to connect a file stdin and :&gt; (same as :1&gt;) to connect a file to stdout. These can also be used with file descriptors (for example :2&gt; will connect a file to stderr). They can be mixed with other shell redirects and will just become part of the redirect stack. Each lisp redirect will return a file in a list (first element will be the PID of the final process).</p>
<p>Examples:
(let ([pid, out] (sh "ls" :&gt;)) (iter::for l in (iter::iter out) (pr l)))</p>
<p>(let ([pid, out, er] (sh "ls vm/src/ sdsdf" :&gt; :2&gt;))(prn "PID: " pid) (iter::for l in (iter::iter out)(pr "from out: " l))(iter::for l in (iter::iter er)(pr "from err: " l)</p>
<p>Set the lisp pipe then use a shell redirect to also send stderr to the same pipe:
(let ([pid, out] (sh "ls vm/src/ sdsdf" :&gt; "2&gt;&amp;1"))(prn "PID: " pid) (iter::for l in (iter::iter out)(pr "from grep: " l)))</p>
<p>(let ([pid, in, out] (sh :&lt; "grep XX" :&gt;))(prn "PID: " pid) (fprn in "XXsls")(fprn in "sls")(fprn in "dfdXX")(fclose in)(iter::for l in (iter::iter out)(pr "from grep: " l)))</p>
<p>(same as above but include a pipe between shell commands)
(let ([pid, in, out] (sh :&lt; "grep XX | cat -" :&gt;)) (fprn in "XXsls")(fprn in "sls")(fprn in "dfdXX")(fclose in)(iter::for l in (iter::iter out)(pr l)))</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-bindings"><a class="header" href="#let-bindings">LET Bindings</a></h1>
<h2 id="basic-form"><a class="header" href="#basic-form">Basic form</a></h2>
<p>(let ([name value]<em>) forms</em>)</p>
<p>Let will create a new lexical scope and will bind names to local variables with provided values. After the binding it is
an implicit do form. The bound symbols will only be in scope within this implicit do. Afterwards they will be unbound
or will revert to their previous shadowed value.</p>
<p>Note all bindings are required to be pairs (name value), name is a symbol and value can be any form (it will be
evaluated).</p>
<p>Let will shadow any variable names from outer scopes (including globals), it does not interact with dynamic scopes at
all.
Let is similar to let-rec in scheme, the bindings are created in order and later binding can see the values of previous
bindings. It will also allow an early reference to "see" a later binding (like let-rec) allowing some recursive forms to
be bound easily. Note that when doing this the later form must NOT be something being shadowed or the existing binding
will be used not the new one in the let.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) `(~a ~b ~c))

;; =&gt; (1 2 3)
</code></pre>
<p>Produces (1 2 3)</p>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) (let (b 20, c (+ b 10)) `(~a ~b ~c)))

;; =&gt; (1 20 30)
</code></pre>
<p>Produces (1 20 30)</p>
<pre><code class="language-slosh">(let (a 1, b 2, c 3) (let (x (+ b 1), b 20, c (+ b 10)) `(~a ~x ~b ~c)))

;; =&gt; (1 3 20 30)
</code></pre>
<p>Produces (1 3 20 30)</p>
<pre><code class="language-slosh">(let (fnx (fn (x) (if (= x 0) #t (fny (- x 1))))
      fny (fn (y) (if (= y 0) #t (fnx (- y 1)))))
    (fnx 10))

;; =&gt; true
</code></pre>
<p>Example of recursive references (a dumb one). It will produce #t (true) after ping ponging between fnx and fny.</p>
<pre><code class="language-slosh">(let (fny (fn (y) y))
    (let (fnx (fn (x) (if (= x 0) #t (fny (- x 1))))
          fny (fn (y) (if (= y 0) #t (fnx (- y 1)))))
        (fny 10)))

;; =&gt; 8
</code></pre>
<p>This example will produce 8 because fnx will use the outer fny instead of the next fny.</p>
<h2 id="destructure-bindings"><a class="header" href="#destructure-bindings">Destructure bindings</a></h2>
<p>Let supports destructure bindings of sequences (list, vector) and hashmaps. It can support optional bindings as well
as rest (&amp;) for sequences.</p>
<p>For sequences use [name+], if &amp; is before the last name then it will get all the leftover values. A % indicates that all
the names after are optional (default to nil) and you can use := to set the default value. Patterns must match exactly,
for instance [a b c] requires a sequence with exactly three elements.  [a b c &amp; rest] requires a sequence with at least
three elements.  [% a b c &amp; rest] will take any sequence and bind the first, second and third values to a b and c if
available.</p>
<p>For maps use {[name key]+} (i.e. a map of symbols to keys), if this map contains :or then it's value will be a map of
key to default value used for any missing keys. It requires all keys to be included in the destructured map or to have a
default.</p>
<p>Note that destructures can be applied recursively and sequence destructure can contain map destructures and vice versa.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-slosh">(def x '(1 2 3))
(let ([a b c] x) `(~a ~b ~c))

;; =&gt; (1 2 3)
</code></pre>
<p>Produces (1 2 3).</p>
<pre><code class="language-slosh">(let ([a b % c d] '(1 2)) (list a b c d))

;; =&gt; (1 2 nil nil)
</code></pre>
<p>Produces (1 2 nil nil).</p>
<pre><code class="language-slosh">(let ({a :one, b 'two, c "three" [d e] :vec} {:one 1, 'two 2, "three" 3, :vec [4 5]}) (list a b c d e))

;; =&gt; (1 2 3 4 5)
</code></pre>
<p>Produces (1 2 3 4 5).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces-1"><a class="header" href="#namespaces-1">Namespaces</a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Namespaces are compiler bookkeeping for organizing global symbols.  When in a namespace then any symbols that are defined will have the current NAMESPACE:: prepended to the symbol.  When symbols are resolved the compiler will also try to prepend the current namespace first in order to find the symbol.</p>
<h2 id="entering-a-namespace-1"><a class="header" href="#entering-a-namespace-1">Entering a namespace</a></h2>
<p>From code use the 'with-ns' form.</p>
<pre><code class="language-slosh">(doc 'with-ns)

;; =&gt; "Usage: (with-ns SYMBOL sexp+)
;;    
;;    Create a namespace and compile sexp+ within it.  Restore the previous namespace when scope ends.
;;    THe symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: core
;;    
;;    Example:
;;    (with-ns test-with-ns
;;        (def ttf (fn () '(1 2 3)))
;;        (test::assert-equal '(1 2 3) (ttf))
;;        (test::assert-equal '(1 2 3) (test-out::ttf)))
;;    (test::assert-equal '(1 2 3) (test-out::ttf))
;;    "
</code></pre>
<p>From the top-level REPL you can use 'ns'.</p>
<pre><code class="language-slosh">(doc 'ns)

;; =&gt; "Usage: (ns SYMBOL)
;;    
;;    Changes to namespace.  This is "open-ended" change and is intended for use with
;;    the REPL prefer with-ns for scripts.
;;    The symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
;;    This will cause all globals defined to have namespace:: prepended.
;;    This will also clear any existing imports.
;;    
;;    Section: core
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    "
</code></pre>
<p>This is an open-ended namespace change intended for the repl, prefer with-ns for a scoped namespace in code.</p>
<h2 id="imports-1"><a class="header" href="#imports-1">Imports</a></h2>
<p>Other namespaces can be imported to allow its symbols to be accessed in a shorter form.  Use the 'import' form for this .</p>
<pre><code class="language-slosh">(doc 'import)

;; =&gt; "Usage: (import namespace [:as symbol])
;;    
;;    Will import a namespace.  Without an :as then all symbols in the namespace will become available in the current
;;    namespace as if local.  With [:as symbol] then all namespace symbols become available with symbol:: prepended.
;;    
;;    Section: core
;;    
;;    Example:
;;    (ns testing)
;;    (def x #t)
;;    (test::assert-true x)
;;    (ns ::)
;;    (test::assert-true testing::x)
;;    (import testing)
;;    (test::assert-true x)
;;    (import testing :as t)
;;    (test::assert-true t::x)
;;    "
</code></pre>
<p>For instance using <code>(import iter)</code> will allow any symbols in the iter namespace to be used without prepending 'iter::'.  You can also use the <code>(import iter :as i)</code>, the :as form allows the namespace to be given a different name.  In this case the iter namespace could be replaced with 'i', (i::for ...) instead of (iter::for ...) for example.  Imports are resolved in the order they are compiled in case of conflict (i.e. the first import that resolves a symbol wins).  Imports are attached to the current namespace, changing namespaces will clear imports (note that 'with-ns' saves and restores the previous namespace with imports).</p>
<h2 id="loading-code-1"><a class="header" href="#loading-code-1">Loading code</a></h2>
<p>To load new code into your environment use load or run-script.</p>
<h3 id="load-1"><a class="header" href="#load-1">Load</a></h3>
<p>The load form should generally be preferred.  It will compile the code at compile time (vs runtime) and execute it at runtime.  This means:</p>
<ul>
<li>The path parameter has to be known at compile time: a string const, defined global or form that does not need local inputs.</li>
<li>Any symbols defined in the loaded code will be known to the compiler at compile time and available for use.</li>
</ul>
<pre><code class="language-slosh">(doc 'load)

;; =&gt; "Usage: (load path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).  The load special form executes at compile time.
;;    This means it's parameter must resolve at compile time.  Most of the time you will want to use
;;    this in conjunction with 'with-ns' to namespace the contents.
;;    Note: on it's own does nothing with namespaces.
;;    
;;    Section: core
;;    
;;    Example:
;;    (comp-time (def test-temp-file (get-temp-file)) nil)
;;    (defer (fs-rm test-temp-file))
;;    (let (tst-file (fopen test-temp-file :create))
;;        (defer (fclose tst-file))
;;        (fprn tst-file "(with-ns test-load")
;;        (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;    (load test-temp-file) ; put stuff in it's own namespace
;;    (test::assert-equal '(1 2 3) (test-load::test-fn))
;;    
;;    
;;    (with-ns test-out2
;;        (comp-time
;;            (def test-temp-file (get-temp-file))
;;            (let (tst-file (fopen test-temp-file :create))
;;                (defer (fclose tst-file))
;;                (fprn tst-file "(defn test-fn () '(1 2 3))"))
;;            nil)
;;        (defer (fs-rm test-temp-file))
;;        (load test-temp-file) ; put new stuff in current namespace
;;        (test::assert-equal '(1 2 3) (test-fn))
;;        (test::assert-equal '(1 2 3) (test-out2::test-fn)))
;;    "
</code></pre>
<h3 id="run-script-1"><a class="header" href="#run-script-1">Run Script</a></h3>
<p>The run-script form loads each form in the file, compiles and executes it at runtime.  This means:</p>
<ul>
<li>It can take any parameter since it is resolved at runtime.</li>
<li>Globals it defines will NOT be known until after it runs at runtime.</li>
</ul>
<pre><code class="language-slosh">(doc 'run-script)

;; =&gt; "Usage: (run-script path) -&gt; [last form value]
;;    
;;    Read and eval a file (from path- a string).
;;    
;;    Section: scripting
;;    
;;    Example:
;;    (def test-load::test-fn)
;;    (with-temp-file (fn (tmp)
;;        (let (tst-file (fopen tmp :create))
;;            (defer (fclose tst-file))
;;            (fprn tst-file "(with-ns test-load")
;;            (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
;;        (run-script tmp)
;;        (test::assert-equal '(1 2 3) (test-load::test-fn))))
;;    "
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-example-of-slosh-execution"><a class="header" href="#end-to-end-example-of-slosh-execution">End to End example of Slosh execution</a></h1>
<ol>
<li>Start with the lisp program <code>(1.1)</code></li>
<li>In <code>reader.rs</code></li>
</ol>
<ul>
<li>The <code>read_inner</code> function controls most parsing.
<ul>
<li>Numeric parsing happens at the end in the catch-all of the match statement.</li>
</ul>
</li>
<li>The <code>do_atom</code> function attempts to parse 1.1 as an i64 and fails, so it parses it as f64 and then calls <code>.into()</code> to convert to a <code>Value</code></li>
</ul>
<ol start="3">
<li>In <code>main.rs</code></li>
</ol>
<ul>
<li>The <code>exec_expression</code> function calls <code>pass1</code></li>
<li>And then it calls <code>compile</code></li>
</ul>
<ol start="4">
<li>In <code>pass1.rs</code></li>
</ol>
<ul>
<li>The <code>pass1</code> function initially operates on (1.1) as a pair or list</li>
<li>It iterates over each element of the list and recursively calls <code>pass1</code> on each element</li>
<li>So then <code>pass1</code> is called on 1.1 which is then handled in the catch-all of the match statement</li>
<li>and this is where we add 1.1 to the heap and add it is a constant to the vm</li>
</ul>
<ol start="5">
<li>In <code>state.rs</code></li>
</ol>
<ul>
<li><code>add_constant</code> is called which inserts the <code>Value</code> of 1.1 into <code>pub struct CompileState</code>'s <code>pub constants: HashMap&lt;Value, usize&gt;</code></li>
<li>Since constants are stored in a hashmap, if two different numeric constants hash to the same thing, they will be stored as the same constant</li>
</ul>
<ol start="6">
<li>In <code>float_56.rs</code></li>
</ol>
<ul>
<li><code>F56</code> impl's the <code>Hash</code> trait and has a custom implementation of <code>hash</code> that converts the <code>F56</code> to a <code>u64</code> and then hashes the result</li>
</ul>
<ol start="7">
<li>In <code>compile.rs</code></li>
</ol>
<ul>
<li>Recall that <code>exec_expression</code> called <code>compile</code> after <code>pass1</code></li>
<li>calls to <code>compile</code> trickle down into <code>compile_list</code>, <code>compile_special</code>, <code>compile_math</code>, and others.</li>
<li><code>compile_list</code> handles a single value like this and the match statement catch-all prints Boo and the value itself</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slosh-forms"><a class="header" href="#slosh-forms">Slosh Forms</a></h1>
<p>List of sections:</p>
<p><a href="src/generated-sections/all.html#section-char">char</a>, <a href="src/generated-sections/all.html#section-collection">collection</a>, <a href="src/generated-sections/all.html#section-conditional">conditional</a>, <a href="src/generated-sections/all.html#section-conversion">conversion</a>, <a href="src/generated-sections/all.html#section-core">core</a>, <a href="src/generated-sections/all.html#section-doc">doc</a>, <a href="src/generated-sections/all.html#section-file">file</a>, <a href="src/generated-sections/all.html#section-hashmap">hashmap</a>, <a href="src/generated-sections/all.html#section-io">io</a>, <a href="src/generated-sections/all.html#section-iterator">iterator</a>, <a href="src/generated-sections/all.html#section-math">math</a>, <a href="src/generated-sections/all.html#section-pair">pair</a>, <a href="src/generated-sections/all.html#section-random">random</a>, <a href="src/generated-sections/all.html#section-scripting">scripting</a>, <a href="src/generated-sections/all.html#section-sequence">sequence</a>, <a href="src/generated-sections/all.html#section-shell">shell</a>, <a href="src/generated-sections/all.html#section-string">string</a>, <a href="src/generated-sections/all.html#section-system">system</a>, <a href="src/generated-sections/all.html#section-test">test</a>, <a href="src/generated-sections/all.html#section-type">type</a>, <a href="src/generated-sections/all.html#section-vector">vector</a></p>
<h2 id="section-char"><a class="header" href="#section-char">Section: char</a></h2>
<p><a href="src/generated-sections/char.html#char-lower">char-lower</a>, <a href="src/generated-sections/char.html#char-upper">char-upper</a>, <a href="src/generated-sections/char.html#char-whitespace">char-whitespace?</a>, <a href="src/generated-sections/char.html#str-int">str-&gt;int</a></p>
<h2 id="section-collection"><a class="header" href="#section-collection">Section: collection</a></h2>
<p><a href="src/generated-sections/collection.html#clear">clear!</a>, <a href="src/generated-sections/collection.html#empty">empty?</a>, <a href="src/generated-sections/collection.html#flatten">flatten</a>, <a href="src/generated-sections/collection.html#in">in?</a>, <a href="src/generated-sections/collection.html#not-empty">not-empty?</a>, <a href="src/generated-sections/collection.html#reverse">reverse</a></p>
<h2 id="section-conditional"><a class="header" href="#section-conditional">Section: conditional</a></h2>
<p><a href="src/generated-sections/conditional.html#">&lt;</a>, <a href="src/generated-sections/conditional.html#">&lt;=</a>, <a href="src/generated-sections/conditional.html#">==</a>, <a href="src/generated-sections/conditional.html#">&gt;</a>, <a href="src/generated-sections/conditional.html#">&gt;=</a>, <a href="src/generated-sections/conditional.html#and">and</a>, <a href="src/generated-sections/conditional.html#cond">cond</a>, <a href="src/generated-sections/conditional.html#if">if</a>, <a href="src/generated-sections/conditional.html#match">match</a>, <a href="src/generated-sections/conditional.html#not">not</a>, <a href="src/generated-sections/conditional.html#or">or</a>, <a href="src/generated-sections/conditional.html#when">when</a></p>
<h2 id="section-conversion"><a class="header" href="#section-conversion">Section: conversion</a></h2>
<p><a href="src/generated-sections/conversion.html#-key">-&gt;key</a>, <a href="src/generated-sections/conversion.html#-sym">-&gt;sym</a>, <a href="src/generated-sections/conversion.html#def">def?</a>, <a href="src/generated-sections/conversion.html#ref">ref</a></p>
<h2 id="section-core"><a class="header" href="#section-core">Section: core</a></h2>
<p><a href="src/generated-sections/core.html#">=</a>, <a href="src/generated-sections/core.html#apply">apply</a>, <a href="src/generated-sections/core.html#back-quote">back-quote</a>, <a href="src/generated-sections/core.html#block">block</a>, <a href="src/generated-sections/core.html#comp-time">comp-time</a>, <a href="src/generated-sections/core.html#dec">dec!</a>, <a href="src/generated-sections/core.html#def">def</a>, <a href="src/generated-sections/core.html#defmacro">defmacro</a>, <a href="src/generated-sections/core.html#defn">defn</a>, <a href="src/generated-sections/core.html#do">do</a>, <a href="src/generated-sections/core.html#doc">doc</a>, <a href="src/generated-sections/core.html#dotimes">dotimes</a>, <a href="src/generated-sections/core.html#dotimes-i">dotimes-i</a>, <a href="src/generated-sections/core.html#dyn">dyn</a>, <a href="src/generated-sections/core.html#err">err</a>, <a href="src/generated-sections/core.html#eval">eval</a>, <a href="src/generated-sections/core.html#fn">fn</a>, <a href="src/generated-sections/core.html#get-error">get-error</a>, <a href="src/generated-sections/core.html#get-globals">get-globals</a>, <a href="src/generated-sections/core.html#get-in-namespace">get-in-namespace</a>, <a href="src/generated-sections/core.html#get-namespaces">get-namespaces</a>, <a href="src/generated-sections/core.html#identity">identity</a>, <a href="src/generated-sections/core.html#import">import</a>, <a href="src/generated-sections/core.html#inc">inc!</a>, <a href="src/generated-sections/core.html#len">len</a>, <a href="src/generated-sections/core.html#let">let</a>, <a href="src/generated-sections/core.html#let-while">let-while</a>, <a href="src/generated-sections/core.html#load">load</a>, <a href="src/generated-sections/core.html#loop">loop</a>, <a href="src/generated-sections/core.html#macro">macro</a>, <a href="src/generated-sections/core.html#mk-err">mk-err</a>, <a href="src/generated-sections/core.html#not">not=</a>, <a href="src/generated-sections/core.html#not">not==</a>, <a href="src/generated-sections/core.html#ns">ns</a>, <a href="src/generated-sections/core.html#nsubstitute">nsubstitute!</a>, <a href="src/generated-sections/core.html#occurs">occurs</a>, <a href="src/generated-sections/core.html#on-raised-error">on-raised-error</a>, <a href="src/generated-sections/core.html#quote">quote</a>, <a href="src/generated-sections/core.html#recur">recur</a>, <a href="src/generated-sections/core.html#set">set!</a>, <a href="src/generated-sections/core.html#substitute">substitute</a>, <a href="src/generated-sections/core.html#to-list">to-list</a>, <a href="src/generated-sections/core.html#to-vec">to-vec</a>, <a href="src/generated-sections/core.html#usage">usage</a>, <a href="src/generated-sections/core.html#with-ns">with-ns</a></p>
<h2 id="section-doc"><a class="header" href="#section-doc">Section: doc</a></h2>
<p><a href="src/generated-sections/doc.html#build-doc">build-doc</a>, <a href="src/generated-sections/doc.html#doc-map">doc-map</a>, <a href="src/generated-sections/doc.html#get-exemptions">get-exemptions</a>, <a href="src/generated-sections/doc.html#get-globals-sorted">get-globals-sorted</a>, <a href="src/generated-sections/doc.html#legacyforms">legacy_forms</a></p>
<h2 id="section-file"><a class="header" href="#section-file">Section: file</a></h2>
<p><a href="src/generated-sections/file.html#cd">cd</a>, <a href="src/generated-sections/file.html#fclose">fclose</a>, <a href="src/generated-sections/file.html#fflush">fflush</a>, <a href="src/generated-sections/file.html#fopen">fopen</a>, <a href="src/generated-sections/file.html#fs-accessed">fs-accessed</a>, <a href="src/generated-sections/file.html#fs-base">fs-base</a>, <a href="src/generated-sections/file.html#fs-crawl">fs-crawl</a>, <a href="src/generated-sections/file.html#fs-dir">fs-dir?</a>, <a href="src/generated-sections/file.html#fs-exists">fs-exists?</a>, <a href="src/generated-sections/file.html#fs-file">fs-file?</a>, <a href="src/generated-sections/file.html#fs-len">fs-len</a>, <a href="src/generated-sections/file.html#fs-modified">fs-modified</a>, <a href="src/generated-sections/file.html#fs-parent">fs-parent</a>, <a href="src/generated-sections/file.html#fs-rm">fs-rm</a>, <a href="src/generated-sections/file.html#fs-same">fs-same?</a>, <a href="src/generated-sections/file.html#get-temp">get-temp</a>, <a href="src/generated-sections/file.html#get-temp-file">get-temp-file</a>, <a href="src/generated-sections/file.html#glob">glob</a>, <a href="src/generated-sections/file.html#read">read</a>, <a href="src/generated-sections/file.html#read-all">read-all</a>, <a href="src/generated-sections/file.html#read-line">read-line</a>, <a href="src/generated-sections/file.html#temp-dir">temp-dir</a>, <a href="src/generated-sections/file.html#with-temp">with-temp</a>, <a href="src/generated-sections/file.html#with-temp-file">with-temp-file</a></p>
<h2 id="section-hashmap"><a class="header" href="#section-hashmap">Section: hashmap</a></h2>
<p><a href="src/generated-sections/hashmap.html#hash-keys">hash-keys</a>, <a href="src/generated-sections/hashmap.html#hash-remove">hash-remove!</a>, <a href="src/generated-sections/hashmap.html#make-hash">make-hash</a></p>
<h2 id="section-io"><a class="header" href="#section-io">Section: io</a></h2>
<p><a href="src/generated-sections/io.html#fs-meta">fs-meta</a></p>
<h2 id="section-iterator"><a class="header" href="#section-iterator">Section: iterator</a></h2>
<p><a href="src/generated-sections/iterator.html#iterenumerate">iter::enumerate</a>, <a href="src/generated-sections/iterator.html#iterfile-iter">iter::file-iter</a>, <a href="src/generated-sections/iterator.html#iterfilter">iter::filter</a>, <a href="src/generated-sections/iterator.html#iterfor">iter::for</a>, <a href="src/generated-sections/iterator.html#iteriter">iter::iter</a>, <a href="src/generated-sections/iterator.html#iteriter-or-single">iter::iter-or-single</a>, <a href="src/generated-sections/iterator.html#iteriter">iter::iter?</a>, <a href="src/generated-sections/iterator.html#iterlist-iter">iter::list-iter</a>, <a href="src/generated-sections/iterator.html#itermap">iter::map</a>, <a href="src/generated-sections/iterator.html#itermk-iter">iter::mk-iter</a>, <a href="src/generated-sections/iterator.html#iteronce-iter">iter::once-iter</a>, <a href="src/generated-sections/iterator.html#iterrange">iter::range</a>, <a href="src/generated-sections/iterator.html#iterreduce">iter::reduce</a>, <a href="src/generated-sections/iterator.html#iterrepeat-iter">iter::repeat-iter</a>, <a href="src/generated-sections/iterator.html#iterstring-iter">iter::string-iter</a>, <a href="src/generated-sections/iterator.html#itervec-iter">iter::vec-iter</a>, <a href="src/generated-sections/iterator.html#itervec-iter-pair">iter::vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#itervec-iter-rev">iter::vec-iter-rev</a></p>
<h2 id="section-math"><a class="header" href="#section-math">Section: math</a></h2>
<p><a href="src/generated-sections/math.html#">%</a>, <a href="src/generated-sections/math.html#">*</a>, <a href="src/generated-sections/math.html#">+</a>, <a href="src/generated-sections/math.html#-">-</a>, <a href="src/generated-sections/math.html#">/</a>, <a href="src/generated-sections/math.html#abs">abs</a>, <a href="src/generated-sections/math.html#rem">rem</a>, <a href="src/generated-sections/math.html#remeuclid">rem_euclid</a></p>
<h2 id="section-pair"><a class="header" href="#section-pair">Section: pair</a></h2>
<p><a href="src/generated-sections/pair.html#car">car</a>, <a href="src/generated-sections/pair.html#cdr">cdr</a>, <a href="src/generated-sections/pair.html#list">list</a>, <a href="src/generated-sections/pair.html#xar">xar!</a>, <a href="src/generated-sections/pair.html#xdr">xdr!</a></p>
<h2 id="section-random"><a class="header" href="#section-random">Section: random</a></h2>
<p><a href="src/generated-sections/random.html#probool">probool</a>, <a href="src/generated-sections/random.html#random">random</a>, <a href="src/generated-sections/random.html#random-str">random-str</a></p>
<h2 id="section-scripting"><a class="header" href="#section-scripting">Section: scripting</a></h2>
<p><a href="src/generated-sections/scripting.html#run-script">run-script</a></p>
<h2 id="section-sequence"><a class="header" href="#section-sequence">Section: sequence</a></h2>
<p><a href="src/generated-sections/sequence.html#butlast">butlast</a>, <a href="src/generated-sections/sequence.html#first">first</a>, <a href="src/generated-sections/sequence.html#last">last</a>, <a href="src/generated-sections/sequence.html#rest">rest</a>, <a href="src/generated-sections/sequence.html#seq-for">seq-for</a></p>
<h2 id="section-shell"><a class="header" href="#section-shell">Section: shell</a></h2>
<p><a href="src/generated-sections/shell.html#args"><em>args</em></a>, <a href="src/generated-sections/shell.html#shell-exe"><em>shell-exe</em></a></p>
<h2 id="section-string"><a class="header" href="#section-string">Section: string</a></h2>
<p><a href="src/generated-sections/string.html#str">str</a>, <a href="src/generated-sections/string.html#str-bytes">str-bytes</a>, <a href="src/generated-sections/string.html#str-cat-list">str-cat-list</a>, <a href="src/generated-sections/string.html#str-contains">str-contains</a>, <a href="src/generated-sections/string.html#str-empty">str-empty?</a>, <a href="src/generated-sections/string.html#str-lower">str-lower</a>, <a href="src/generated-sections/string.html#str-map">str-map</a>, <a href="src/generated-sections/string.html#str-push">str-push!</a>, <a href="src/generated-sections/string.html#str-replace">str-replace</a>, <a href="src/generated-sections/string.html#str-split">str-split</a>, <a href="src/generated-sections/string.html#str-splitn">str-splitn</a>, <a href="src/generated-sections/string.html#str-starts-with">str-starts-with</a>, <a href="src/generated-sections/string.html#str-sub">str-sub</a>, <a href="src/generated-sections/string.html#str-trim">str-trim</a>, <a href="src/generated-sections/string.html#str-trim">str-trim!</a>, <a href="src/generated-sections/string.html#str-upper">str-upper</a></p>
<h2 id="section-system"><a class="header" href="#section-system">Section: system</a></h2>
<p><a href="src/generated-sections/system.html#sleep">sleep</a></p>
<h2 id="section-test"><a class="header" href="#section-test">Section: test</a></h2>
<p><a href="src/generated-sections/test.html#testassert-equal">test::assert-equal</a>, <a href="src/generated-sections/test.html#testassert-error">test::assert-error</a>, <a href="src/generated-sections/test.html#testassert-error-msg">test::assert-error-msg</a>, <a href="src/generated-sections/test.html#testassert-false">test::assert-false</a>, <a href="src/generated-sections/test.html#testassert-not-equal">test::assert-not-equal</a>, <a href="src/generated-sections/test.html#testassert-true">test::assert-true</a></p>
<h2 id="section-type"><a class="header" href="#section-type">Section: type</a></h2>
<p><a href="src/generated-sections/type.html#callable">callable?</a>, <a href="src/generated-sections/type.html#char">char?</a>, <a href="src/generated-sections/type.html#err">err?</a>, <a href="src/generated-sections/type.html#io">io?</a>, <a href="src/generated-sections/type.html#list">list?</a>, <a href="src/generated-sections/type.html#nil">nil?</a>, <a href="src/generated-sections/type.html#ok">ok?</a>, <a href="src/generated-sections/type.html#pair">pair?</a>, <a href="src/generated-sections/type.html#seq">seq?</a>, <a href="src/generated-sections/type.html#str-float">str-&gt;float</a>, <a href="src/generated-sections/type.html#string">string?</a>, <a href="src/generated-sections/type.html#symbol">symbol?</a>, <a href="src/generated-sections/type.html#vec">vec?</a></p>
<h2 id="section-vector"><a class="header" href="#section-vector">Section: vector</a></h2>
<p><a href="src/generated-sections/vector.html#make-vec">make-vec</a>, <a href="src/generated-sections/vector.html#vec">vec</a>, <a href="src/generated-sections/vector.html#vec-list">vec-&gt;list</a>, <a href="src/generated-sections/vector.html#vec-pop">vec-pop!</a>, <a href="src/generated-sections/vector.html#vec-push">vec-push!</a>, <a href="src/generated-sections/vector.html#vec-slice">vec-slice</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="char"><a class="header" href="#char">char</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/char.html#char-lower">char-lower</a>, <a href="src/generated-sections/char.html#char-upper">char-upper</a>, <a href="src/generated-sections/char.html#char-whitespace">char-whitespace?</a>, <a href="src/generated-sections/char.html#str-int">str-&gt;int</a></p>
<h3 id="char-lower"><a class="header" href="#char-lower">char-lower</a></h3>
<p><strong>Usage:</strong> (char-lower char) -&gt; char</p>
<p>Get lower case (utf) string for a character.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "a" (char-lower \A))
(test::assert-equal "a" (char-lower \a))
(test::assert-not-equal "a" (char-lower \Z))
(test::assert-equal "λ" (char-lower \Λ))
(test::assert-equal "λ" (char-lower \λ))
(test::assert-equal "ß" (char-lower \ß))
</code></pre>
<h3 id="char-upper"><a class="header" href="#char-upper">char-upper</a></h3>
<p><strong>Usage:</strong> (char-upper char) -&gt; char</p>
<p>Get upper case (utf) string for a character.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "A" (char-upper \A))
(test::assert-equal "A" (char-upper \a))
(test::assert-not-equal "A" (char-upper \Z))
(test::assert-equal "Λ" (char-upper \λ))
(test::assert-equal "Λ" (char-upper \Λ))
;; "the" exception and a reason for returning a string
(test::assert-equal "SS" (char-upper \ß))
</code></pre>
<h3 id="char-whitespace"><a class="header" href="#char-whitespace">char-whitespace?</a></h3>
<p><strong>Usage:</strong> (char-whitespace? char) -&gt; t/nil</p>
<p>Returns true if a character is whitespace, false/nil otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (char-whitespace? \ ))
(test::assert-true (char-whitespace? \tab))
(test::assert-false (char-whitespace? \s))
</code></pre>
<h3 id="str-int"><a class="header" href="#str-int">str-&gt;int</a></h3>
<p><strong>Usage:</strong> (str-&gt;int string) -&gt; int</p>
<p>If string is a valid representation of an integer return that int.  Error if not.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (str-&gt;int "0"))
(test::assert-equal 101 (str-&gt;int "101"))
(test::assert-equal -101 (str-&gt;int "-101"))
(test::assert-error (str-&gt;int "not int"))
(test::assert-error (str-&gt;int "10.0"))
(test::assert-error (str-&gt;int "--10"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="collection"><a class="header" href="#collection">collection</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/collection.html#clear">clear!</a>, <a href="src/generated-sections/collection.html#empty">empty?</a>, <a href="src/generated-sections/collection.html#flatten">flatten</a>, <a href="src/generated-sections/collection.html#in">in?</a>, <a href="src/generated-sections/collection.html#not-empty">not-empty?</a>, <a href="src/generated-sections/collection.html#reverse">reverse</a></p>
<h3 id="clear"><a class="header" href="#clear">clear!</a></h3>
<p><strong>Usage:</strong> (clear! container)</p>
<p>Clears a container (vector, hash-map, string).  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-clear-vec (vec 1 2 3))
(test::assert-false (empty? test-clear-vec))
(clear! test-clear-vec)
(test::assert-true (empty? test-clear-vec))
</code></pre>
<h3 id="empty"><a class="header" href="#empty">empty?</a></h3>
<p><strong>Usage:</strong> (empty? v)</p>
<p>Usage (empty? s)</p>
<p>No Examples</p>
<h3 id="flatten"><a class="header" href="#flatten">flatten</a></h3>
<p><strong>Usage:</strong> (flatten &amp; rest)</p>
<p>Takes a sequence composed of individual values or sequences of values and turns
it into one vector of values.</p>
<p>Example:</p>
<pre><code>(test::assert-equal [1 2 3 1 2 3] (flatten 1 2 3 (list 1 2 3)))
(test::assert-equal [1 2 3 1 2 3] (flatten 1 2 3 [1 2 3]))
(test::assert-equal [1 2 3 1 2] (flatten 1 2 3 (list 1 2)))
(test::assert-equal [1 2 3 1 2 3 1 2] (flatten 1 2 3 (list 1 2 3 (list 1 2))))
</code></pre>
<h3 id="in"><a class="header" href="#in">in?</a></h3>
<p><strong>Usage:</strong> (in? needle haystack)</p>
<p>In provided sequence, haystack, find a specific value, needle.</p>
<p>Example:</p>
<pre><code>(test::assert-true (in? [1 2 3 4 5] 3))
(test::assert-false (in? [1 2 3 4 5] 9))
(test::assert-true (in? (list 1 2 3 4 5) 3))
(test::assert-true (in? '(1 2 3 4 5) 5))
</code></pre>
<h3 id="not-empty"><a class="header" href="#not-empty">not-empty?</a></h3>
<p><strong>Usage:</strong> (not-empty? v)</p>
<p>Usage (not-empty? s)</p>
<p>No Examples</p>
<h3 id="reverse"><a class="header" href="#reverse">reverse</a></h3>
<p><strong>Usage:</strong> (reverse items)</p>
<p>Produce a vector that is the reverse of items.</p>
<p>Example:</p>
<pre><code>(let (tmap [1 2 3 0])
(test::assert-false (empty? tmap))
(set! tmap (reverse tmap))
(test::assert-equal 2 (get tmap 2))
(test::assert-equal 1 (get tmap 3))
(test::assert-equal 0 (get tmap 0))
(test::assert-error (reverse "string")))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conditional"><a class="header" href="#conditional">conditional</a></h2>
<p>{{ #include section-docs/conditional.md }}</p>
<p>List of symbols:</p>
<p><a href="src/generated-sections/conditional.html#">&lt;</a>, <a href="src/generated-sections/conditional.html#">&lt;=</a>, <a href="src/generated-sections/conditional.html#">==</a>, <a href="src/generated-sections/conditional.html#">&gt;</a>, <a href="src/generated-sections/conditional.html#">&gt;=</a>, <a href="src/generated-sections/conditional.html#and">and</a>, <a href="src/generated-sections/conditional.html#cond">cond</a>, <a href="src/generated-sections/conditional.html#if">if</a>, <a href="src/generated-sections/conditional.html#match">match</a>, <a href="src/generated-sections/conditional.html#not">not</a>, <a href="src/generated-sections/conditional.html#or">or</a>, <a href="src/generated-sections/conditional.html#when">when</a></p>
<h3 id=""><a class="header" href="#">&lt;</a></h3>
<p><strong>Usage:</strong> (&lt; val0 ... valN)</p>
<p>Less than.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt; 1 2))
(test::assert-true (&lt; 1 2 3 4))
(test::assert-false (&lt; 2 2))
(test::assert-false (&lt; 2 2 2))
(test::assert-false (&lt; 2 2 3))
(test::assert-true (&lt; 1.0 2.0))
(test::assert-false (&lt; 2.0 2.0))
(test::assert-false (&lt; 2.0 2.0 2.0))
(test::assert-false (&lt; 2.0 2.0 3.0))
(test::assert-false (&lt; 2.1 2.0 3.0))
(test::assert-false (&lt; 2 1))
(test::assert-false (&lt; 3 2 3))
(test::assert-true (&lt; 1.0 1.1 ))
(test::assert-true (&lt; 1.0 1.01 ))
(test::assert-true (&lt; 1.0 1.001 ))
(test::assert-true (&lt; 1.0 1.0001 ))
(test::assert-true (&lt; 1.0 1.00001 ))
(test::assert-true (&lt; 1.0 1.000001 ))
(test::assert-true (&lt; 1.0 1.0000001 ))
(test::assert-false (&lt; 1.0 1.00000000000001 ))
</code></pre>
<h3 id="-1"><a class="header" href="#-1">&lt;=</a></h3>
<p><strong>Usage:</strong> (&lt;= val0 ... valN)</p>
<p>Less than or equal.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-true (&lt;= 1 2))
(test::assert-true (&lt;= 2 2))
(test::assert-true (&lt;= 2 2 2))
(test::assert-true (&lt;= 2 2 3))
(test::assert-true (&lt;= 1.0 2.0))
(test::assert-true (&lt;= 2.0 2.0))
(test::assert-true (&lt;= 2.0 2.0 2.0))
(test::assert-true (&lt;= 2.0 2.0 3.0))
(test::assert-false (&lt;= 2.1 2.0 3.0))
(test::assert-false (&lt;= 2 1))
(test::assert-false (&lt;= 3 2 3))
(test::assert-true (&lt;= 1.00000000000001 1.0000000000001 ))
(test::assert-true (&lt;= 10.0000000000001 10.000000000001))
(test::assert-true (&lt;= 100.000000000001 100.00000000001))
(test::assert-true (&lt;= 1000.000000000001 1000.00000000001))
</code></pre>
<h3 id="-2"><a class="header" href="#-2">==</a></h3>
<p><strong>Usage:</strong> (== val0 ... valN)</p>
<p>Equals.  Works for numeric types (int, float).</p>
<p>Example:</p>
<pre><code>(test::assert-false (== 1 2))
(test::assert-true (== 2 2))
(test::assert-true (== 2 2 2))
(test::assert-false (== 3 2 2))
(test::assert-false (== 3.0 2.0))
(test::assert-true (== 2.0 2.0))
(test::assert-true (== 2.0 2.0 2.0))
(test::assert-false (== 3.0 2.0 2.0))
(test::assert-false (== 2.1 2.0 3.0))
(test::assert-false (== 2 1))
(test::assert-false (== 3 2 1))
(test::assert-false (== 1.1 1.0))
(test::assert-true (== 1.1 1.1))
(test::assert-false (== 3 2 3))
</code></pre>
<h3 id="-3"><a class="header" href="#-3">&gt;</a></h3>
<p><strong>Usage:</strong> (&gt; val0 ... valN)</p>
<p>Greater than.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-false (&gt; 1 2))
(test::assert-false (&gt; 2 2))
(test::assert-false (&gt; 2 2 2))
(test::assert-false (&gt; 3 2 2))
(test::assert-true (&gt; 3.0 2.0))
(test::assert-false (&gt; 2.0 2.0))
(test::assert-false (&gt; 2.0 2.0 2.0))
(test::assert-false (&gt; 3.0 2.0 2.0))
(test::assert-false (&gt; 2.1 2.0 3.0))
(test::assert-true (&gt; 2 1))
(test::assert-true (&gt; 3 2 1))
(test::assert-true (&gt; 1.1 1.0))
(test::assert-false (&gt; 3 2 3))
(test::assert-true (&gt; 1.001 1.0))
(test::assert-true (&gt; 1.0000001 1.0))
(test::assert-false (&gt; 1.00000000000001 1.0))
</code></pre>
<h3 id="-4"><a class="header" href="#-4">&gt;=</a></h3>
<p><strong>Usage:</strong> (&gt;= val0 ... valN)</p>
<p>Greater than or equal.  Works for int, float or string.</p>
<p>Example:</p>
<pre><code>(test::assert-false (&gt;= 1 2))
(test::assert-true (&gt;= 2 2))
(test::assert-true (&gt;= 2 2 2))
(test::assert-true (&gt;= 3 2 2))
(test::assert-true (&gt;= 3.0 2.0))
(test::assert-true (&gt;= 2.0 2.0))
(test::assert-true (&gt;= 2.0 2.0 2.0))
(test::assert-true (&gt;= 3.0 2.0 2.0))
(test::assert-false (&gt;= 2.1 2.0 3.0))
(test::assert-true (&gt;= 2 1))
(test::assert-true (&gt;= 1.1 1.0))
(test::assert-false (&gt;= 3 2 3))
(test::assert-true (&gt;= 1.0000000000001 1.00000000000001))
(test::assert-true (&gt;= 10.000000000001 10.0000000000001))
(test::assert-true (&gt;= 100.00000000001 100.000000000001))
(test::assert-true (&gt;= 1000.00000000001 1000.000000000001))
</code></pre>
<h3 id="and"><a class="header" href="#and">and</a></h3>
<p><strong>Usage:</strong> (and exp0 ... expN) -&gt; [false(#f) or expN result]</p>
<p>Evaluates each form until one produces nil or false(#f), produces false(#f) if
any form is nil/#f or the result of the last expression.</p>
<p>The and form will stop evaluating when the first expression produces nil/#f.</p>
<p>Example:</p>
<pre><code>(test::assert-equal #f (and nil (err "and- can not happen")))
(test::assert-equal #f (and #f (err "and- can not happen")))
(test::assert-equal "and- done" (and #t "and- done"))
(test::assert-equal "and- done" (and #t #t "and- done"))
(test::assert-equal 6 (and #t #t (+ 1 2 3)))
(test::assert-equal 6 (and (/ 10 5) (* 5 2) (+ 1 2 3)))
</code></pre>
<h3 id="cond"><a class="header" href="#cond">cond</a></h3>
<p><strong>Usage:</strong> (cond ((test form*)*) -&gt; result</p>
<p>Evaluate each test in order.  If it is true then evaluate the form(s) in an
implicit do and return the result.  Stop evaluating at the first true test.
Return nil if no conditions are true.</p>
<p>Example:</p>
<pre><code>(def b 0)
(defn select-option (a)
    (cond ((= a 1) "opt-one")
          ((= a 2) (set! b 5) "opt-two")
          ((= a 3) (str "opt" "-three"))))
(defn select-option-def (a)
    (cond ((= a 1) "opt-one")
          ((= a 2) "opt-two")
          ((= a 3) (str "opt" "-three"))
          (#t "default")))
(test::assert-equal "opt-one" (select-option 1))
(test::assert-equal b 0)
(test::assert-equal "opt-two" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal "opt-three" (select-option 3))
(test::assert-equal nil (select-option 4))
(test::assert-equal "opt-one" (select-option-def 1))
(test::assert-equal "opt-two" (select-option-def 2))
(test::assert-equal "opt-three" (select-option-def 3))
(test::assert-equal "default" (select-option-def 4))
</code></pre>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p><strong>Usage:</strong> (if p1 a1 p2 a2 ... pn an?) -&gt; [evaled form result]</p>
<p>If conditional.  Will evaluate p1 and if true (i.e. not nil or false) then
return the evaluation of a1, if falsey(i.e. nil or false) evaluate p2 and so on.
On an odd number of arguments (an is missing) then evaluate and return pn.
Return false(#f) if no predicate is true.  This degenerates into the traditional
(if predicate then-form else-form).
NOTE: Both nil and false(#f) are 'falsey' for the purposes of if.</p>
<p>Example:</p>
<pre><code>(def test-if-one
    (if #t "ONE TRUE" "ONE FALSE"))
(def test-if-two
    (if nil "TWO TRUE" "TWO FALSE"))
(def test-if-three
    (if #f "THREE TRUE" "THREE FALSE"))
(test::assert-equal "ONE TRUE" test-if-one)
(test::assert-equal "TWO FALSE" test-if-two)
(test::assert-equal "THREE FALSE" test-if-three)

(def test-if-one2
    (if #t "ONE2 TRUE"))
(def test-if-two2
    (if nil "TWO2 TRUE"))
(def test-if-three2
    (if #f "THREE2 TRUE"))
(test::assert-equal "ONE2 TRUE" test-if-one2)
(test::assert-equal #f test-if-two2)
(test::assert-equal #f test-if-three2)

(def test-if-one2
    (if nil "ONE FALSE" #t "ONE TRUE" #t "ONE TRUE2"))
(def test-if-two2
    (if nil "TWO TRUE" #f "TWO FALSE" #t "TWO TRUE2"))
(def test-if-three2
    (if #f "THREE TRUE" nil "THREE FALSE" "THREE DEFAULT"))
(test::assert-equal "ONE TRUE" test-if-one2)
(test::assert-equal "TWO TRUE2" test-if-two2)
(test::assert-equal "THREE DEFAULT" test-if-three2)
(test::assert-equal nil (if nil))
(test::assert-equal #f (if nil #t nil #t nil #t))
</code></pre>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<p><strong>Usage:</strong> (match condition (value form*)*) -&gt; result</p>
<p>Evaluate condition and look for matching value in each branch of type
(value form*). Form(s) will be wrapped in an implicit do. Use nil to take
action if no match (encouraged!).</p>
<p>Example:</p>
<pre><code>(defn select-option (a)
    (match a (1 "opt-one")
             (2 (set! b 5) "opt-two")
             (3 (str "opt" "-three"))))
(defn select-option-def (a)
    (match a (1 "opt-one")
             (2 "opt-two")
             (3 (str "opt" "-three"))
             (nil "default")))
(def b 0)
(test::assert-equal b 0)
(test::assert-equal "opt-one" (select-option 1))
(test::assert-equal "opt-two" (select-option 2))
(test::assert-equal b 5)
(test::assert-equal "opt-three" (select-option 3))
(test::assert-equal #f (select-option 4))
(test::assert-equal "opt-one" (select-option-def 1))
(test::assert-equal "opt-two" (select-option-def 2))
(test::assert-equal "opt-three" (select-option-def 3))
(test::assert-equal "default" (select-option-def 4))
</code></pre>
<h3 id="not"><a class="header" href="#not">not</a></h3>
<p><strong>Usage:</strong> (not expression)</p>
<p>Return true(#t) if expression is nil, false(#f) otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (not nil))
(test::assert-false (not 10))
(test::assert-false (not #t))
(test::assert-false (not (+ 1 2 3)))
</code></pre>
<h3 id="or"><a class="header" href="#or">or</a></h3>
<p><strong>Usage:</strong> (or exp0 ... expN) -&gt; [false(#f) or first non nil expression]</p>
<p>Evaluates each form until one produces a non-nil/non-false result, produces #f
if all expressions are 'falsey'.</p>
<p>The or form will stop evaluating when the first expression produces non-nil/false.</p>
<p>Example:</p>
<pre><code>(test::assert-true (or nil nil #t (err "and- can not happen")))
(test::assert-true (or #f nil #t (err "and- can not happen")))
(test::assert-true (or #f #f #t (err "and- can not happen")))
(test::assert-equal #f (or nil nil nil))
(test::assert-equal #f (or #f nil nil))
(test::assert-equal #f (or #f nil #f))
(test::assert-equal #f (or #f #f #f))
(test::assert-equal "or- done" (or nil "or- done"))
(test::assert-equal "or- done" (or nil nil "or- done"))
(test::assert-equal 6 (or nil nil (+ 1 2 3)))
(test::assert-equal 2 (or (/ 10 5) (* 5 2) (+ 1 2 3)))
</code></pre>
<h3 id="when"><a class="header" href="#when">when</a></h3>
<p><strong>Usage:</strong> (when provided-condition if-true)</p>
<p>when is a convenience function used to check a form, provided-condition,
and run some form, if-true, if provided-condition evaluates to true.</p>
<p>Example:</p>
<pre><code>(test::assert-true (when #t #t))
(test::assert-false (when #t nil))
(test::assert-false (when nil nil))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="conversion"><a class="header" href="#conversion">conversion</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/conversion.html#-key">-&gt;key</a>, <a href="src/generated-sections/conversion.html#-sym">-&gt;sym</a>, <a href="src/generated-sections/conversion.html#def">def?</a>, <a href="src/generated-sections/conversion.html#ref">ref</a></p>
<h3 id="-key"><a class="header" href="#-key">-&gt;key</a></h3>
<p><strong>Usage:</strong> (-&gt;key exp) -&gt; keyword</p>
<p>Converts exp to a keyword.</p>
<p>No Examples</p>
<h3 id="-sym"><a class="header" href="#-sym">-&gt;sym</a></h3>
<p><strong>Usage:</strong> (-&gt;sym exp) -&gt; symbol</p>
<p>Converts exp to a symbol.</p>
<p>No Examples</p>
<h3 id="def"><a class="header" href="#def">def?</a></h3>
<p><strong>Usage:</strong> (def? symbol) -&gt; #t/#f</p>
<p>If symbol is defined then return true else false.</p>
<p>No Examples</p>
<h3 id="ref"><a class="header" href="#ref">ref</a></h3>
<p><strong>Usage:</strong> (ref symbol) -&gt; Value</p>
<p>If symbol is defined then return the thing it references.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="core"><a class="header" href="#core">core</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/core.html#">=</a>, <a href="src/generated-sections/core.html#apply">apply</a>, <a href="src/generated-sections/core.html#back-quote">back-quote</a>, <a href="src/generated-sections/core.html#block">block</a>, <a href="src/generated-sections/core.html#comp-time">comp-time</a>, <a href="src/generated-sections/core.html#dec">dec!</a>, <a href="src/generated-sections/core.html#def">def</a>, <a href="src/generated-sections/core.html#defmacro">defmacro</a>, <a href="src/generated-sections/core.html#defn">defn</a>, <a href="src/generated-sections/core.html#do">do</a>, <a href="src/generated-sections/core.html#doc">doc</a>, <a href="src/generated-sections/core.html#dotimes">dotimes</a>, <a href="src/generated-sections/core.html#dotimes-i">dotimes-i</a>, <a href="src/generated-sections/core.html#dyn">dyn</a>, <a href="src/generated-sections/core.html#err">err</a>, <a href="src/generated-sections/core.html#eval">eval</a>, <a href="src/generated-sections/core.html#fn">fn</a>, <a href="src/generated-sections/core.html#get-error">get-error</a>, <a href="src/generated-sections/core.html#get-globals">get-globals</a>, <a href="src/generated-sections/core.html#get-in-namespace">get-in-namespace</a>, <a href="src/generated-sections/core.html#get-namespaces">get-namespaces</a>, <a href="src/generated-sections/core.html#identity">identity</a>, <a href="src/generated-sections/core.html#import">import</a>, <a href="src/generated-sections/core.html#inc">inc!</a>, <a href="src/generated-sections/core.html#len">len</a>, <a href="src/generated-sections/core.html#let">let</a>, <a href="src/generated-sections/core.html#let-while">let-while</a>, <a href="src/generated-sections/core.html#load">load</a>, <a href="src/generated-sections/core.html#loop">loop</a>, <a href="src/generated-sections/core.html#macro">macro</a>, <a href="src/generated-sections/core.html#mk-err">mk-err</a>, <a href="src/generated-sections/core.html#not">not=</a>, <a href="src/generated-sections/core.html#not">not==</a>, <a href="src/generated-sections/core.html#ns">ns</a>, <a href="src/generated-sections/core.html#nsubstitute">nsubstitute!</a>, <a href="src/generated-sections/core.html#occurs">occurs</a>, <a href="src/generated-sections/core.html#on-raised-error">on-raised-error</a>, <a href="src/generated-sections/core.html#quote">quote</a>, <a href="src/generated-sections/core.html#recur">recur</a>, <a href="src/generated-sections/core.html#set">set!</a>, <a href="src/generated-sections/core.html#substitute">substitute</a>, <a href="src/generated-sections/core.html#to-list">to-list</a>, <a href="src/generated-sections/core.html#to-vec">to-vec</a>, <a href="src/generated-sections/core.html#usage">usage</a>, <a href="src/generated-sections/core.html#with-ns">with-ns</a></p>
<h3 id="-5"><a class="header" href="#-5">=</a></h3>
<p><strong>Usage:</strong> (= val0 val1)</p>
<p>Test equality, works for most value types where it makes sense, not just primitives.</p>
<p>Example:</p>
<pre><code>(test::assert-false (= "aab" "aaa"))
(test::assert-true (= "aaa" "aaa"))
(test::assert-true (= "aaa" "aaa" "aaa"))
(test::assert-false (= "aaa" "aaaa" "aaa"))
(test::assert-false (= "ccc" "aab" "aaa"))
(test::assert-false (= "aaa" "aab"))
(test::assert-true (= (get-error (/ 1 0)) (get-error (/ 1 0))))
</code></pre>
<h3 id="apply"><a class="header" href="#apply">apply</a></h3>
<p><strong>Usage:</strong> (apply function arg* list)</p>
<p>Call the provided function with the supplied arguments, if last is a list or vector then it will
be "spread" as arguments.  For instance (apply pr 1 2 3 [4 5 6]) is equivalent to (pr 1 2 3 4 5 6).</p>
<p>Example:</p>
<pre><code>(def test-apply-one (apply str "O" "NE"))
(test::assert-equal "ONE" test-apply-one)
(test::assert-equal 10 (apply + 1 2 7))
(test::assert-equal 10 (apply + 1 [2 7]))
(test::assert-equal 10 (apply + 1 '(2 7)))
(test::assert-equal 10 (apply + [1 2 7]))
(test::assert-equal 10 (apply + '(1 2 7)))
(def test-apply-fn1 (fn (&amp; args) (apply + args)))
(test::assert-equal 10 (apply test-apply-fn1 1 2 7))
(test::assert-equal 10 (apply test-apply-fn1 1 [2 7]))
(test::assert-equal 10 (apply test-apply-fn1 1 '(2 7)))
(test::assert-equal 10 (apply test-apply-fn1 [1 2 7]))
(test::assert-equal 10 (apply test-apply-fn1 '(1 2 7)))
(def test-apply-fn2 (fn (x y z) (+ x y z)))
(test::assert-equal 10 (apply test-apply-fn2 1 2 7))
(test::assert-equal 10 (apply test-apply-fn2 1 [2 7]))
(test::assert-equal 10 (apply test-apply-fn2 1 '(2 7)))
(test::assert-equal 10 (apply test-apply-fn2 [1 2 7]))
(test::assert-equal 10 (apply test-apply-fn2 '(1 2 7)))
</code></pre>
<h3 id="back-quote"><a class="header" href="#back-quote">back-quote</a></h3>
<p><strong>Usage:</strong> `expression -&gt; expression</p>
<p>Return expression without evaluation.
Always use the ` reader macro or expansion will not work
(i.e. (back-quote expression) will not do , expansion).</p>
<p>Backquote (unlike quote) allows for symbol/form evaluation using , or ,@.</p>
<p>Example:</p>
<pre><code>(test::assert-equal (list 1 2 3) `(1 2 3))
(test::assert-equal `(1 2 3) '(1 2 3))
(def test-bquote-one 1)
(def test-bquote-list '(1 2 3))
(test::assert-equal (list 1 2 3) `(~test-bquote-one 2 3))
(test::assert-equal (list 1 2 3) `(~@test-bquote-list))
</code></pre>
<h3 id="block"><a class="header" href="#block">block</a></h3>
<p><strong>Usage:</strong> (get-error exp0 ... expN) -&gt; pair</p>
<p>Evaluate each form (like do) but on error return (:error msg backtrace) instead of aborting.
On success return (:ok . expN-result).</p>
<p>If there is no error will return the value of the last expression as the cdr of
the pair.  Always returns a pair with the first value either being :ok or :error.</p>
<p>Example:</p>
<pre><code>(let (get-error-t1 (get-error (err (mk-err :string (str "Some Error")))))
    (test::assert-equal :error (car get-error-t1))
    (test::assert-equal "error [string]: \"Some Error\"" (str (cdr get-error-t1))))
(test::assert-equal "Some String" (get-error "Some String"))
(test::assert-equal "Some Other String" (get-error (let (test-get-error "Some ") (str test-get-error "Other String"))))
</code></pre>
<h3 id="comp-time"><a class="header" href="#comp-time">comp-time</a></h3>
<p><strong>Usage:</strong> (comp-time sexp+)</p>
<p>Compile and execute sexp+ at compile time.  The result of the final sexp will then be compiled into
the current module being compiled (produce nil to avoid this).</p>
<p>Example:</p>
<pre><code>(with-ns test-out
    (comp-time '(def ttf (fn () '(1 2 3))))
    (comp-time (def ttf2 (fn () '(1 2 3))) nil)
    (test::assert-equal '(1 2 3) (ttf))
    (test::assert-equal '(1 2 3) (test-out::ttf))
    (test::assert-equal '(1 2 3) (ttf2))
    (test::assert-equal '(1 2 3) (test-out::ttf2)))
</code></pre>
<h3 id="dec"><a class="header" href="#dec">dec!</a></h3>
<p><strong>Usage:</strong> (dec! symbol [number]) -&gt; new value</p>
<p>Decrement the value in symbol by one or the optional number</p>
<p>Example:</p>
<pre><code>(def *dec-test* 5)
(test::assert-equal 4 (dec! *dec-test*))
(test::assert-equal 4 *dec-test*)
(test::assert-equal 1 (dec! *dec-test* 3))
(test::assert-equal 1 *dec-test*)
(let (dec-test 5)
  (test::assert-equal 4 (dec! dec-test))
  (test::assert-equal 4 dec-test)
  (test::assert-equal 1 (dec! dec-test 3))
  (test::assert-equal 1 dec-test))
</code></pre>
<h3 id="def-1"><a class="header" href="#def-1">def</a></h3>
<p><strong>Usage:</strong> (def symbol doc_string? expression) -&gt; expression</p>
<p>Adds an expression to the current namespace.  Return the expression that was defined.
Symbol is not evaluated.  Can take an option doc string (docstrings can only be
set on namespaced (global) symbols).</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One")(set! test-do-two "Two")"Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
(let (test-do-one nil)
    ; Add this to the let's scope (shadow the outer test-do-two).
    (test::assert-equal "Default" (def test-do-four "Default"))
    ; set the currently scoped value.
    (set! test-do-one "1111")
    (set! test-do-two "2222")
    (test::assert-equal "1111" test-do-one)
    (test::assert-equal "2222" test-do-two)
    (test::assert-equal "Default" test-do-four))
; Original outer scope not changed.
(test::assert-equal "One" test-do-one)
(test::assert-equal "Default" test-do-four)
</code></pre>
<h3 id="defmacro"><a class="header" href="#defmacro">defmacro</a></h3>
<p><strong>Usage:</strong> (defmacro name argument_list body)</p>
<p>Create a macro and bind it to a symbol in the current scope.</p>
<p>Example:</p>
<pre><code>(defmacro test-mac (x) `(inc! ~x))
(def test-mac-x 2)
(test-mac test-mac-x)
(test::assert-equal 3 test-mac-x)
(defmacro test-mac (x) `(set! ~x 15))
(test-mac test-mac-x)
(test::assert-equal 15 test-mac-x)
</code></pre>
<h3 id="defn"><a class="header" href="#defn">defn</a></h3>
<p><strong>Usage:</strong> (defn name args body)</p>
<p>Define a named function in the current namespace.</p>
<p>Example:</p>
<pre><code>(defn defn-test (x y) (+ x y))
(test::assert-equal 5 (defn-test 2 3))
(defn defn-test (x y) (set! x (* x 2)) (+ x y))
(test::assert-equal 7 (defn-test 2 3))
(defn defn-test (x y) nil)
(test::assert-false (defn-test 2 3))
(defn defn-test (x y) #t)
(test::assert-true (defn-test 2 3))
</code></pre>
<h3 id="do"><a class="header" href="#do">do</a></h3>
<p><strong>Usage:</strong> (do exp0 ... expN) -&gt; expN</p>
<p>Evaluate each form and return the last.</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One") (set! test-do-two "Two") "Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
</code></pre>
<h3 id="doc"><a class="header" href="#doc">doc</a></h3>
<p><strong>Usage:</strong> (doc sym [SCRATCH] [SCRATCH] docs has-usage)</p>
<p>Print the documentation for provided symbol.</p>
<p>No Examples</p>
<h3 id="dotimes"><a class="header" href="#dotimes">dotimes</a></h3>
<p><strong>Usage:</strong> (dotimes times body [SCRATCH] [SCRATCH] i-name)</p>
<p>Evaluate body a number of times equal to times' numerical value.</p>
<p>Example:</p>
<pre><code>(def i 0)
(dotimes 11 (set! i (+ 1 i)))
(test::assert-equal 11 i)
</code></pre>
<h3 id="dotimes-i"><a class="header" href="#dotimes-i">dotimes-i</a></h3>
<p><strong>Usage:</strong> (dotimes-i idx-bind times body)</p>
<p>Evaluate body a number of times equal to times' numerical value. Includes an
incrementing reference binding, idx-bind, accessible in body.</p>
<p>Example:</p>
<pre><code>(def i 0)
(def i-tot 0)
(dotimes-i idx 11 (do (set! i-tot (+ idx i-tot))(set! i (+ 1 i))))
(test::assert-equal 11 i)
(test::assert-equal 55 i-tot)
</code></pre>
<h3 id="dyn"><a class="header" href="#dyn">dyn</a></h3>
<p><strong>Usage:</strong> (dyn key value expression) -&gt; result_of_expression</p>
<p>Creates a dynamic binding for key, assigns value to it and evals expression under it.
Note that if key must be a symbol and is not evaluated.</p>
<p>The binding is gone once the dyn form ends. This is basically a set! on the
binding in an unwind protect to reset it when done.  When used on a global will
set the first binding found and reset it when done.
Calls to dyn can be nested and previous dynamic values will
be restored as interior dyn's exit.</p>
<p>Example:</p>
<pre><code>(def *dyn-test* 1)
(defn test-dyn-fn (val) (str *dyn-test* val))
(def out (dyn *dyn-test* 11 (test-dyn-fn 101)))
(test::assert-equal "11101" (str out))
;; when file handling works
;;(defn test-dyn-fn () (prn "Print dyn out"))
;;(dyn *stdout* (open "/tmp/sl-sh.dyn.test" :create :truncate) (test-dyn-fn))
;;(test::assert-equal "Print dyn out" (read-line (open "/tmp/sl-sh.dyn.test" :read)))
</code></pre>
<h3 id="err"><a class="header" href="#err">err</a></h3>
<p><strong>Usage:</strong> (err :keyword value)</p>
<p>Raises an error with keyword and value.  By default this will break into the
debugger like a runtime error (use get-error to avoid this).</p>
<p>Example:</p>
<pre><code>(let (error (get-error (err :test "Test error")))
    (test::assert-equal :test (car error))
    (test::assert-equal "Test error" (cdr error))
    (test::assert-true (err? error)))
</code></pre>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p><strong>Usage:</strong> (eval expression)</p>
<p>Evaluate the provided expression.  If expression is a list it will be compiled and executed and the result returned
other values will just be returned (i.e. (eval 1) = 1, (eval "test") = "test", (eval [1 2 3]) = [1 2 3], etc).</p>
<p>Note eval is a function not a special form, the provided expression will be evaluated as part of a call.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "ONE" (eval "ONE"))
(test::assert-equal 10 (eval 10))
(test::assert-equal [1 2 3] (eval [1 2 3]))
(test::assert-equal 10 (eval '(+ 1 2 7)))
(test::assert-equal 10 (eval '(apply + 1 2 7)))
(test::assert-equal 10 (eval '(apply + 1 '(2 7))))
(test::assert-equal 10 (eval '(apply + '(1 2 7))))
(test::assert-equal 10 (eval '(apply + 1 [2 7])))
(test::assert-equal 10 (eval '(apply + [1 2 7])))
</code></pre>
<h3 id="fn"><a class="header" href="#fn">fn</a></h3>
<p><strong>Usage:</strong> (fn (param*) expr*) -&gt; exprN</p>
<p>Create a function (lambda).</p>
<p>Example:</p>
<pre><code>(def test-fn1 nil)
(def test-fn2 nil)
(def test-fn3 nil)
(def test-fn-empty ((fn () nil)))
(test::assert-false test-fn-empty)
((fn () (set! test-fn1 1)))
(test::assert-equal 1 test-fn1)
((fn () (set! test-fn1 10)(set! test-fn2 2)))
(test::assert-equal 10 test-fn1)
(test::assert-equal 2 test-fn2)
((fn () (set! test-fn1 11)(set! test-fn2 20)(set! test-fn3 3)))
(test::assert-equal 11 test-fn1)
(test::assert-equal 20 test-fn2)
(test::assert-equal 3 test-fn3)
((fn (x y z) (set! test-fn1 x)(set! test-fn2 y)(set! test-fn3 z)) 12 21 30)
(test::assert-equal 12 test-fn1)
(test::assert-equal 21 test-fn2)
(test::assert-equal 30 test-fn3)
(test::assert-equal 63 ((fn (x y z) (set! test-fn1 x)(set! test-fn2 y)(set! test-fn3 z)(+ x y z)) 12 21 30))
</code></pre>
<h3 id="get-error"><a class="header" href="#get-error">get-error</a></h3>
<p><strong>Usage:</strong> (get-error exp0 ... expN) -&gt; pair</p>
<p>Evaluate each form (like do) but on error return (:error msg backtrace) instead of aborting.
On success return (:ok . expN-result).</p>
<p>If there is no error will return the value of the last expression as the cdr of
the pair.  Always returns a pair with the first value either being :ok or :error.</p>
<p>Example:</p>
<pre><code>(let (get-error-t1 (get-error (err (mk-err :string (str "Some Error")))))
    (test::assert-equal :error (car get-error-t1))
    (test::assert-equal "error [string]: \"Some Error\"" (str (cdr get-error-t1))))
(test::assert-equal "Some String" (get-error "Some String"))
(test::assert-equal "Some Other String" (get-error (let (test-get-error "Some ") (str test-get-error "Other String"))))
</code></pre>
<h3 id="get-globals"><a class="header" href="#get-globals">get-globals</a></h3>
<p><strong>Usage:</strong> (get-globals)</p>
<p>Return a vector containing all the symbols currently defined globally.</p>
<p>No Examples</p>
<h3 id="get-in-namespace"><a class="header" href="#get-in-namespace">get-in-namespace</a></h3>
<p><strong>Usage:</strong> (get-in-namespace 'SYMBOL)</p>
<p>Return a vector containing all the globals currently defined namespace SYMBOL.</p>
<p>No Examples</p>
<h3 id="get-namespaces"><a class="header" href="#get-namespaces">get-namespaces</a></h3>
<p><strong>Usage:</strong> (get-namespaces)</p>
<p>Return a vector containing all the namespaces currently defined globally.</p>
<p>No Examples</p>
<h3 id="identity"><a class="header" href="#identity">identity</a></h3>
<p><strong>Usage:</strong> (identity arg)</p>
<p>Identity function.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (identity 0))
</code></pre>
<h3 id="import"><a class="header" href="#import">import</a></h3>
<p><strong>Usage:</strong> (import namespace [:as symbol])</p>
<p>Will import a namespace.  Without an :as then all symbols in the namespace will become available in the current
namespace as if local.  With [:as symbol] then all namespace symbols become available with symbol:: prepended.</p>
<p>Example:</p>
<pre><code>(ns testing)
(def x #t)
(test::assert-true x)
(ns ::)
(test::assert-true testing::x)
(import testing)
(test::assert-true x)
(import testing :as t)
(test::assert-true t::x)
</code></pre>
<h3 id="inc"><a class="header" href="#inc">inc!</a></h3>
<p><strong>Usage:</strong> (inc! symbol [number]) -&gt; new value</p>
<p>Increment the value in symbol by one or the optional number</p>
<p>Example:</p>
<pre><code>(def *inc-test* 1)
(test::assert-equal 2 (inc! *inc-test*))
(test::assert-equal 2 *inc-test*)
(test::assert-equal 5 (inc! *inc-test* 3))
(test::assert-equal 5 *inc-test*)
(let (inc-test 1)
  (test::assert-equal 2 (inc! inc-test))
  (test::assert-equal 2 inc-test)
  (test::assert-equal 5 (inc! inc-test 3))
  (test::assert-equal 5 inc-test))
</code></pre>
<h3 id="len"><a class="header" href="#len">len</a></h3>
<p><strong>Usage:</strong> (len expression) -&gt; int</p>
<p>Return length of supplied expression.  The length of an atom is 1.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (len nil))
(test::assert-equal 5 (len "12345"))
; Note the unicode symbol is only one char even though it is more then one byte.
(test::assert-equal 6 (len "12345Σ"))
(test::assert-equal 3 (len '(1 2 3)))
(test::assert-equal 3 (len [1 2 3]))
(test::assert-equal 3 (len (list 1 2 3)))
(test::assert-equal 3 (len (vec 1 2 3)))
(test::assert-equal 1 (len 100))
(test::assert-equal 1 (len 100.0))
(test::assert-equal 1 (len \tab))
</code></pre>
<h3 id="let"><a class="header" href="#let">let</a></h3>
<p><strong>Usage:</strong> (let vals &amp;rest let-body)</p>
<p>Takes list, vals, of form ((binding0 sexp0) (binding1 sexp1) ...) and evaluates
let-body with all values of binding bound to the result of the evaluation of
sexp.</p>
<p>Example:</p>
<pre><code>(def test-do-one "One1")
(def test-do-two "Two1")
(def test-do-three (let (test-do-one "One") (set! test-do-two "Two")(test::assert-equal "One" test-do-one)"Three"))
(test::assert-equal "One1" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
((fn (idx) (let (v2 (+ idx 2) v3 (+ idx 3))
    (test::assert-equal (+ idx 2) v2)
    (test::assert-equal (+ idx 3) v3)
    (if (&lt; idx 5) (recur (+ idx 1)))))0)
((fn (idx) (let (v2 (+ idx 2) v3 (+ idx 3))
    (test::assert-equal (+ idx 2) v2)
    (test::assert-equal (+ idx 3) v3)
    (if (&lt; idx 5) (this-fn (+ idx 1)))))0)
</code></pre>
<h3 id="let-while"><a class="header" href="#let-while">let-while</a></h3>
<p><strong>Usage:</strong> (let-while (initial-bindings) (loop bindings) condition &amp; let-body)</p>
<p>Takes list of initial bindings (done once before loop) of form (binding0 sexp0, binding1 sexp1, ...),
and a list of loop bindings (done at the start of each iteration including the first) and evaluates
let-body with all values of binding bound to the result of the evaluation of
both bindings while condition is true.</p>
<p>Example:</p>
<pre><code>; both of these examples create a vector and iterate to print all the elements
; use traditional lisp structure
(def test-res [])
(let-while (l [1 2 3]) (done (empty? l), f (first l),  l (rest l)) (not done)
  (prn f)
  (vec-push! test-res f))
(let ([x y z] test-res)
  (test::assert-equal 1 x)
  (test::assert-equal 2 y)
  (test::assert-equal 3 z))
; same thing using destructuring
(def test-res [])
(let-while (l [1 2 3]) (done (empty? l), [% f &amp; l] l) (not done)
  (prn f)
  (vec-push! test-res f))
(let ([x y z] test-res)
  (test::assert-equal 1 x)
  (test::assert-equal 2 y)
  (test::assert-equal 3 z))
</code></pre>
<h3 id="load-2"><a class="header" href="#load-2">load</a></h3>
<p><strong>Usage:</strong> (load path) -&gt; [last form value]</p>
<p>Read and eval a file (from path- a string).  The load special form executes at compile time.
This means it's parameter must resolve at compile time.  Most of the time you will want to use
this in conjunction with 'with-ns' to namespace the contents.
Note: on it's own does nothing with namespaces.</p>
<p>Example:</p>
<pre><code>(comp-time (def test-temp-file (get-temp-file)) nil)
(defer (fs-rm test-temp-file))
(let (tst-file (fopen test-temp-file :create))
    (defer (fclose tst-file))
    (fprn tst-file "(with-ns test-load")
    (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
(load test-temp-file) ; put stuff in it's own namespace
(test::assert-equal '(1 2 3) (test-load::test-fn))


(with-ns test-out2
    (comp-time
        (def test-temp-file (get-temp-file))
        (let (tst-file (fopen test-temp-file :create))
            (defer (fclose tst-file))
            (fprn tst-file "(defn test-fn () '(1 2 3))"))
        nil)
    (defer (fs-rm test-temp-file))
    (load test-temp-file) ; put new stuff in current namespace
    (test::assert-equal '(1 2 3) (test-fn))
    (test::assert-equal '(1 2 3) (test-out2::test-fn)))
</code></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<p><strong>Usage:</strong> (loop params bindings body)</p>
<p>Binds bindings to parameters in body. Use recur with desired bindings for
subsequent iteration.
Within the loop the lambda 'break' will end the loop, break can take an option
argument that is what the loop produces (nil if no argument).</p>
<p>Example:</p>
<pre><code>(def tot 0)
(loop (idx) (3) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))
(test::assert-equal 3 tot)
(def tot 0)
(loop (idx) (0)
    (set! tot (+ tot 1))
    (when (not (= idx 2))
        (recur (+ idx 1))))
(test::assert-equal 3 tot)
(test::assert-equal 11 (loop (idx) (0)
    (if (= idx 2) (break 11))
    (recur (+ idx 1))))
(test::assert-false (loop (idx) (0)
    (if (= idx 2) (break nil))
    (recur (+ idx 1))))
(test::assert-error (loop (idx) (0)
    (if (= idx 2) (break 1 3))
    (recur (+ idx 1))))
</code></pre>
<h3 id="macro"><a class="header" href="#macro">macro</a></h3>
<p><strong>Usage:</strong> (macro (args) `(apply + ,@args))</p>
<p>Define an anonymous macro.</p>
<p>Example:</p>
<pre><code>(def test-macro1 nil)
(def test-macro2 nil)
(def test-macro-empty (macro () nil))
(test::assert-false (test-macro-empty))
(def test-mac nil)
(def mac-var 2)
(let (mac-var 3)
  (set! test-mac (macro (x) (set! test-macro2 100) (test::assert-equal 3 mac-var) (* mac-var x))))
(set! test-macro1 (test-mac 10))
(test::assert-equal 30 test-macro1)
(test::assert-equal 100 test-macro2)
</code></pre>
<h3 id="mk-err"><a class="header" href="#mk-err">mk-err</a></h3>
<p><strong>Usage:</strong> (mk-err :keyword value)</p>
<p>Create an error object.  This does not raise the error but merely creates it.
Can use car/cdr to extract the keyword and value.</p>
<p>Example:</p>
<pre><code>(let (error (mk-err :test "Test error"))
    (test::assert-equal :test (car error))
    (test::assert-equal "Test error" (cdr error))
    (test::assert-true (err? error)))
</code></pre>
<h3 id="not-1"><a class="header" href="#not-1">not=</a></h3>
<p><strong>Usage:</strong> (not= arg1 arg2)</p>
<p>Test if two values are not equal using <code>=</code></p>
<p>Example:</p>
<pre><code>(test::assert-true (not= 0 1))
(test::assert-true (not= 1 1.0))
(test::assert-false (not= 2 2))
(test::assert-false (not= 0.0 -0.0))
</code></pre>
<h3 id="not-2"><a class="header" href="#not-2">not==</a></h3>
<p><strong>Usage:</strong> (not== arg1 arg2)</p>
<p>Test if two values are not numerically equal using <code>==</code></p>
<p>Example:</p>
<pre><code>(test::assert-true (not== 0 1))
(test::assert-false (not== 1 1.0))
(test::assert-false (not== 0.0 -0.0))
(test::assert-false (not== 2 2))
</code></pre>
<h3 id="ns"><a class="header" href="#ns">ns</a></h3>
<p><strong>Usage:</strong> (ns SYMBOL)</p>
<p>Changes to namespace.  This is "open-ended" change and is intended for use with
the REPL prefer with-ns for scripts.
The symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
This will cause all globals defined to have namespace:: prepended.
This will also clear any existing imports.</p>
<p>Example:</p>
<pre><code>(ns testing)
(def x #t)
(test::assert-true x)
(ns ::)
(test::assert-true testing::x)
</code></pre>
<h3 id="nsubstitute"><a class="header" href="#nsubstitute">nsubstitute!</a></h3>
<p><strong>Usage:</strong> (nsubstitute! lst old-item new-item mods [SCRATCH] [SCRATCH] early-return)</p>
<p>Replaces all instances of old-item in lst with new-item. If last argument
passed in is keyword :first only the first instance of old-item will be
replaced.</p>
<p>Example:</p>
<pre><code>(let (lst (list 1 2 3 4 5))
    (test::assert-equal (list 1 2 2 4 5) (nsubstitute! lst 3 2))
    (test::assert-equal (list 1 2 2 4 5) lst)
    (test::assert-equal (list 1 3 2 4 5) (nsubstitute! lst 2 3 :first)))
</code></pre>
<h3 id="occurs"><a class="header" href="#occurs">occurs</a></h3>
<p><strong>Usage:</strong> (occurs (list 1 2 ...) 7)</p>
<p>Counts instances of item in sequence.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (occurs (list 1 3 5 2 4 8 2 4 88 2 1) 8))
(test::assert-equal 3 (occurs (list 1 3 5 2 4 10 2 4 88 2 1) 2))
(test::assert-equal 0 (occurs (list 1 3 5 2 4 10 2 4 88 2 1) 42))
</code></pre>
<h3 id="on-raised-error"><a class="header" href="#on-raised-error">on-raised-error</a></h3>
<p><strong>Usage:</strong> (on-raised-error (fn (error) ...))</p>
<p>Low level (consider this unstable) interface to the raised error machinery.
Useful for building higher level error handling (get-error for instance).
It takes either Nil or a callable with one parameter.  That parameter will be
the error that was raised.  The entire running "chunk" of code will be
displaced for the installed handler.  Probably best to use this with a
continuation or a function that ends in a continuation call otherwise it
may be difficult to reason about...</p>
<p>Will return the previously installed handler or Nil if one is not installed.
Calling with Nil will return the old handler and clear it (no handler
installed).</p>
<p>This special form will override breaking into the debugger when an error is
raised.</p>
<p>Example:</p>
<pre><code>(defmacro get-error-test (&amp; body)
`(let (old-error (on-raised-error nil))
    (defer (on-raised-error old-error))
    (call/cc (fn (k) (on-raised-error (fn (err) (k (cons (car err)(cdr err)))))
                (cons :ok (do ~@body))))))

(test::assert-equal (cons :ok 6) (get-error-test (let (x 1, y 5) (+ x y))))
(test::assert-equal '(:test . "error") (get-error-test (let (x 1, y 5) (err :test "error")(+ x y))))
</code></pre>
<h3 id="quote"><a class="header" href="#quote">quote</a></h3>
<p><strong>Usage:</strong> 'expression -&gt; expression</p>
<p>Return expression without evaluation.
The reader macro 'expression will expand to (quote expression).</p>
<p>Example:</p>
<pre><code>(test::assert-equal (list 1 2 3) (quote (1 2 3)))
(test::assert-equal (list 1 2 3) '(1 2 3))
(test::assert-equal '(1 2 3) (quote (1 2 3)))
</code></pre>
<h3 id="recur"><a class="header" href="#recur">recur</a></h3>
<p><strong>Usage:</strong> (recur &amp;rest)</p>
<p>Recursively call the enclosing function with the given parameters.  Recur uses
tail call optimization and must be in the tail position or it is an error.  For
a named function it would be equivalent to a normal recursive call in a tail
position but it requires a tail position and does not need a name (a normal
recursive call would work in a non-tail position but could blow the stack if
it is to deep- unlike a recur or tail position recursive call).
NOTE: potential footgun, the let macro expands to a lambda (fn) and a recur used
inside the let would bind with the let not the enclosing lambda (this would
apply to any macro that also expands to a lambda- this is by design with the
loop macro but would be unexpected with let).</p>
<p>Example:</p>
<pre><code>(def tot 0)
(loop (idx) (3) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))
(test::assert-equal 3 tot)
(set! tot 0)
((fn (idx) (do
    (set! tot (+ tot 1))
    (if (&gt; idx 1) (recur (- idx 1)))))5)
(test::assert-equal 5 tot)
</code></pre>
<h3 id="set"><a class="header" href="#set">set!</a></h3>
<p><strong>Usage:</strong> (set! symbol expression) -&gt; expression</p>
<p>Sets an existing expression in the current scope(s).  Return the expression that was set.
Symbol is not evaluated.</p>
<p>Set will set the first binding it finds starting in the current scope and then
trying enclosing scopes until exhausted.</p>
<p>Example:</p>
<pre><code>(def test-do-one nil)
(def test-do-two nil)
(def test-do-three (do (set! test-do-one "One")(set! test-do-two "Two")"Three"))
(test::assert-equal "One" test-do-one)
(test::assert-equal "Two" test-do-two)
(test::assert-equal "Three" test-do-three)
(let (test-do-one nil)
    ; set the currently scoped value.
    (test::assert-equal "1111" (set! test-do-one "1111"))
    (test::assert-equal "1111" test-do-one))
; Original outer scope not changed.
(test::assert-equal "One" test-do-one)
</code></pre>
<h3 id="substitute"><a class="header" href="#substitute">substitute</a></h3>
<p><strong>Usage:</strong> (substitute lst old-item new-item mods)</p>
<p>Replaces all instances of old-item in copy of lst with new-item.  If last
argument passed in is keyword :first only the first instance of old-item will be
replaced.</p>
<p>Example:</p>
<pre><code>(let (lst (list 1 2 3 4 3)
      olst (list 1 2 3 4 3)
       lst2 (list 1 2 3 3 3 4 5)
      olst2 (list 1 2 3 3 3 4 5))
     (test::assert-equal (list 1 2 10 4 10) (substitute lst 3 10))
     (test::assert-equal (list 1 2 10 4 3) (substitute lst 3 10 :first))
     (test::assert-equal olst lst)
     (test::assert-equal (list 1 2 4 4 4 4 5) (substitute lst2 3 4))
     (test::assert-equal (list 1 2 4 3 3 4 5) (substitute lst2 3 4 :first))
     (test::assert-equal olst2 lst2))
</code></pre>
<h3 id="to-list"><a class="header" href="#to-list">to-list</a></h3>
<p><strong>Usage:</strong> (to-list any)</p>
<p>Turns any one value into a list. If that value or if it was a sequence
a new sequence with the same values.</p>
<p>No Examples</p>
<h3 id="to-vec"><a class="header" href="#to-vec">to-vec</a></h3>
<p><strong>Usage:</strong> (to-list any)</p>
<p>Turns any one value into a vector. If that value or if it was a sequence
a new sequence with the same values.</p>
<p>No Examples</p>
<h3 id="usage"><a class="header" href="#usage">usage</a></h3>
<p><strong>Usage:</strong> (usage 'symbol)</p>
<p>Provides usage information derived from the bytecode. Documentation can also have it's
own usage string provided in the doc string but this function returns what the actual
function's compiled code provides.</p>
<p>No Examples</p>
<h3 id="with-ns"><a class="header" href="#with-ns">with-ns</a></h3>
<p><strong>Usage:</strong> (with-ns SYMBOL sexp+)</p>
<p>Create a namespace and compile sexp+ within it.  Restore the previous namespace when scope ends.
THe symbol "::" will return to the "root" namespace (i.e. no namespace prepended to globals).
This will cause all globals defined to have namespace:: prepended.
This will also clear any existing imports.</p>
<p>Example:</p>
<pre><code>(with-ns test-with-ns
    (def ttf (fn () '(1 2 3)))
    (test::assert-equal '(1 2 3) (ttf))
    (test::assert-equal '(1 2 3) (test-out::ttf)))
(test::assert-equal '(1 2 3) (test-out::ttf))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="doc-1"><a class="header" href="#doc-1">doc</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/doc.html#build-doc">build-doc</a>, <a href="src/generated-sections/doc.html#doc-map">doc-map</a>, <a href="src/generated-sections/doc.html#get-exemptions">get-exemptions</a>, <a href="src/generated-sections/doc.html#get-globals-sorted">get-globals-sorted</a>, <a href="src/generated-sections/doc.html#legacyforms">legacy_forms</a></p>
<h3 id="build-doc"><a class="header" href="#build-doc">build-doc</a></h3>
<p><strong>Usage:</strong> (build-doc valid-filepath)</p>
<p>Uses mdbook to build the documentation for the given book.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="doc-map"><a class="header" href="#doc-map">doc-map</a></h3>
<p><strong>Usage:</strong> (doc-map symbol)</p>
<p>Returns documentation for given symbol as map. Keyword is a documentation fragment
(usage, section, description, example) and value is text describing given fragment.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<h3 id="get-exemptions"><a class="header" href="#get-exemptions">get-exemptions</a></h3>
<p><strong>Usage:</strong> (get-exemptions)</p>
<p>Return a vector containing all the symbols currently exempted from docs
(so the build passes), Ideally this will be 0.</p>
<p>No Examples</p>
<h3 id="get-globals-sorted"><a class="header" href="#get-globals-sorted">get-globals-sorted</a></h3>
<p><strong>Usage:</strong> (get-globals-sorted)</p>
<p>Return a vector containing all the symbols currently defined globally in sorted order (alphanumerically).</p>
<p>No Examples</p>
<h3 id="legacy_forms"><a class="header" href="#legacy_forms">legacy_forms</a></h3>
<p><strong>Usage:</strong> (legacy_forms)</p>
<p>Gets list of all forms that were used in the previous version of sl_sh.</p>
<p>Example:</p>
<pre><code>#t
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="file"><a class="header" href="#file">file</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/file.html#cd">cd</a>, <a href="src/generated-sections/file.html#fclose">fclose</a>, <a href="src/generated-sections/file.html#fflush">fflush</a>, <a href="src/generated-sections/file.html#fopen">fopen</a>, <a href="src/generated-sections/file.html#fs-accessed">fs-accessed</a>, <a href="src/generated-sections/file.html#fs-base">fs-base</a>, <a href="src/generated-sections/file.html#fs-crawl">fs-crawl</a>, <a href="src/generated-sections/file.html#fs-dir">fs-dir?</a>, <a href="src/generated-sections/file.html#fs-exists">fs-exists?</a>, <a href="src/generated-sections/file.html#fs-file">fs-file?</a>, <a href="src/generated-sections/file.html#fs-len">fs-len</a>, <a href="src/generated-sections/file.html#fs-modified">fs-modified</a>, <a href="src/generated-sections/file.html#fs-parent">fs-parent</a>, <a href="src/generated-sections/file.html#fs-rm">fs-rm</a>, <a href="src/generated-sections/file.html#fs-same">fs-same?</a>, <a href="src/generated-sections/file.html#get-temp">get-temp</a>, <a href="src/generated-sections/file.html#get-temp-file">get-temp-file</a>, <a href="src/generated-sections/file.html#glob">glob</a>, <a href="src/generated-sections/file.html#read">read</a>, <a href="src/generated-sections/file.html#read-all">read-all</a>, <a href="src/generated-sections/file.html#read-line">read-line</a>, <a href="src/generated-sections/file.html#temp-dir">temp-dir</a>, <a href="src/generated-sections/file.html#with-temp">with-temp</a>, <a href="src/generated-sections/file.html#with-temp-file">with-temp-file</a></p>
<h3 id="cd"><a class="header" href="#cd">cd</a></h3>
<p><strong>Usage:</strong> (cd dir-to-change-to)</p>
<p>Change directory.</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-cd-marker") :create :truncate))
(test::assert-false (fs-exists? "fs-cd-marker"))
(cd tmp)
(test::assert-true (fs-exists? "fs-cd-marker"))
(cd)))
</code></pre>
<h3 id="fclose"><a class="header" href="#fclose">fclose</a></h3>
<p><strong>Usage:</strong> (fclose file)</p>
<p>Close a file.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (tst-file (fopen tmp-file :create :truncate))
        (fprn tst-file "Test Line Two")
        (fclose tst-file)
        (set! tst-file (fopen tmp-file :read))
        (defer (fclose tst-file))
        (test::assert-equal "Test Line Two
" (read-line tst-file)))))
</code></pre>
<h3 id="fflush"><a class="header" href="#fflush">fflush</a></h3>
<p><strong>Usage:</strong> (flush file)</p>
<p>Flush a file.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (tst-file (fopen tmp-file :create :truncate)
          tst-file-read (fopen tmp-file :read))
        (defer (fclose tst-file))
        (defer (fclose tst-file-read))
        (fprn tst-file "Test Line Three")
        (fflush tst-file)
        (test::assert-equal "Test Line Three
" (read-line tst-file-read)))))
</code></pre>
<h3 id="fopen"><a class="header" href="#fopen">fopen</a></h3>
<p><strong>Usage:</strong> (fopen filename option*)</p>
<p>Open a file.  If you use :read and :write then you get a read/write unbuffered file.  Including
one of :read or :write will provide a file buffered for read or write (this is faster).
Note: :append, :truncate, :create, :create-new all imply :write.</p>
<p>Options are:
:read
:write
:append
:truncate
:create
:create-new
:on-error-nil</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
    (let (test-open-f (fopen tmp-file :create :truncate))
        (fprn test-open-f "Test Line One")
        (fclose test-open-f)
        (set! test-open-f (fopen tmp-file :read))
        (defer (fclose test-open-f))
        (test::assert-equal "Test Line One
" (read-line test-open-f)))))
</code></pre>
<h3 id="fs-accessed"><a class="header" href="#fs-accessed">fs-accessed</a></h3>
<p><strong>Usage:</strong> (fs-accessed /path/to/file/or/dir)</p>
<p>Returns the unix time file last accessed in ms.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create)
last-acc (fs-accessed tmp))
(fclose tst-file)
(let (tst-file (fopen tmp :read))
(test::assert-true (&gt;= (fs-accessed tmp) last-acc))
(fclose tst-file)))))
</code></pre>
<h3 id="fs-base"><a class="header" href="#fs-base">fs-base</a></h3>
<p><strong>Usage:</strong> (fs-base /path/to/file/or/dir)</p>
<p>Returns base name of file or directory passed to function.</p>
<p>No Examples</p>
<h3 id="fs-crawl"><a class="header" href="#fs-crawl">fs-crawl</a></h3>
<p><strong>Usage:</strong> (fs-crawl /path/to/file/or/dir (fn (x) (prn "found path" x) [max-depth]
[:follow-syms])</p>
<p>If a directory is provided the path is recursively searched and every
file and directory is called as an argument to the provided function.
If a file is provided the path is provided as an argument to the provided
function. Takes two optional arguments (in any order) an integer,
representing max depth to traverse if file is a directory, or the
symbol, :follow-syms, to follow symbol links when traversing if
desired.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
(let (cnt 0)
(fs-crawl tmp-file (fn (x)
(test::assert-equal (fs-base tmp-file) (fs-base x))
(set! cnt (+ 1 cnt))))
(test::assert-equal 1 cnt))))


(defn create-in (in-dir num-files visited)
(dotimes-i i num-files
(let (tmp-file (get-temp-file in-dir))
(set! visited.~tmp-file #f))))

(defn create-dir (tmp-dir visited)
(let (new-tmp (get-temp tmp-dir))
(set! visited.~new-tmp #f)
new-tmp))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited)
tmp-dir (create-dir tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))))
(test::assert-equal (+ 3 (* 3 tmp-file-count)) cnt)
(test::assert-equal (+ 3 (* 3 tmp-file-count)) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir visited)
new-files (create-in tmp-dir tmp-file-count visited)
tmp-dir (create-dir tmp-dir {})
new-files (do (set! visited.~tmp-dir #f)(create-in tmp-dir tmp-file-count {})))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))) 2)
(test::assert-equal (+ 3 (* 2 tmp-file-count)) cnt)
(test::assert-equal (+ 3 (* 2 tmp-file-count)) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))

(with-temp (fn (root-tmp-dir)
(let (tmp-file-count 5
visited {}
cnt 0)
(set! visited.~root-tmp-dir #f)
(create-in root-tmp-dir tmp-file-count visited)
(let (tmp-dir (create-dir root-tmp-dir {})
new-files (do (set! visited.~tmp-dir #f)(create-in tmp-dir tmp-file-count {}))
tmp-dir (create-dir tmp-dir {})
new-files (create-in tmp-dir tmp-file-count {}))
(fs-crawl root-tmp-dir (fn (x)
(let (file visited.~x)
(test::assert-true (not file)) ;; also tests double counting
(set! visited.~x #t)
(inc! cnt))) 1)
(test::assert-equal (+ 2 tmp-file-count) cnt)
(test::assert-equal (+ 2 tmp-file-count) (len visited))
(seq-for key in (hash-keys visited) (test::assert-true visited.~key))))))
</code></pre>
<h3 id="fs-dir"><a class="header" href="#fs-dir">fs-dir?</a></h3>
<p><strong>Usage:</strong> (fs-dir? path-to-test)</p>
<p>Is the given path a directory?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-dir-file") :create :truncate))
(test::assert-false (fs-dir? (str tmp "/fs-dir-file")))
(test::assert-true (fs-dir? tmp))
(test::assert-false (fs-file? (str tmp "/fs-dir-nope")))))
</code></pre>
<h3 id="fs-exists"><a class="header" href="#fs-exists">fs-exists?</a></h3>
<p><strong>Usage:</strong> (fs-exists? path-to-test)</p>
<p>Does the given path exist?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-exists") :create :truncate))
(test::assert-true (fs-exists? (str tmp "/fs-exists")))
(test::assert-true (fs-exists? tmp))
(test::assert-false (fs-exists? (str tmp "/fs-exists-nope")))))
</code></pre>
<h3 id="fs-file"><a class="header" href="#fs-file">fs-file?</a></h3>
<p><strong>Usage:</strong> (fs-file? path-to-test)</p>
<p>Is the given path a file?</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/fs-file") :create :truncate))
(test::assert-true (fs-file? (str tmp "/fs-file")))
(test::assert-false (fs-file? tmp))
(test::assert-false (fs-file? (str tmp "/fs-file-nope")))))
</code></pre>
<h3 id="fs-len"><a class="header" href="#fs-len">fs-len</a></h3>
<p><strong>Usage:</strong> (fs-len /path/to/file/or/dir)</p>
<p>Returns the size of the file in bytes.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create :truncate))
(fprn tst-file "Test Line Read Line One")
(fpr tst-file "Test Line Read Line Two")
(fclose tst-file)
(test::assert-equal 47 (fs-len tmp)))))
</code></pre>
<h3 id="fs-modified"><a class="header" href="#fs-modified">fs-modified</a></h3>
<p><strong>Usage:</strong> (fs-modified /path/to/file/or/dir)</p>
<p>Returns the unix time file last modified in ms.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
(let (tst-file (fopen tmp :create :truncate)
last-mod (fs-modified tmp))
(fprn tst-file "Test Line Read Line One")
(fpr tst-file "Test Line Read Line Two")
(fflush tst-file)
(fclose tst-file)
(test::assert-true (&gt;= (fs-modified tmp) last-mod)))))
</code></pre>
<h3 id="fs-parent"><a class="header" href="#fs-parent">fs-parent</a></h3>
<p><strong>Usage:</strong> (fs-parent /path/to/file/or/dir)</p>
<p>Returns base name of file or directory passed to function.</p>
<p>No Examples</p>
<h3 id="fs-rm"><a class="header" href="#fs-rm">fs-rm</a></h3>
<p><strong>Usage:</strong> (fs-rm "/dir/or/file/to/remove")</p>
<p>Takes a file or directory as a string and removes it. Works recursively for directories.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(let (a-file (get-temp-file))
(test::assert-true (fs-exists? a-file))
(set! fp a-file)
(fs-rm a-file))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))
</code></pre>
<h3 id="fs-same"><a class="header" href="#fs-same">fs-same?</a></h3>
<p><strong>Usage:</strong> (fs-same? /path/to/file/or/dir /path/to/file/or/dir)</p>
<p>Returns true if the two provided file paths refer to the same file or directory.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp-file)
(test::assert-true (fs-same? tmp-file tmp-file))))
</code></pre>
<h3 id="get-temp"><a class="header" href="#get-temp">get-temp</a></h3>
<p><strong>Usage:</strong> (get-temp ["/path/to/directory/to/use/as/base" "optional-prefix" "optional-suffix" length])</p>
<p>Creates a directory inside of an OS specific temporary directory. See <a href="root::temp-dir">temp-dir</a>
for OS specific notes. Also accepts an optional prefix, an optional suffix, and an optional
length for the random number of characters in the temporary file created. Defaults to prefix of
".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains (get-temp) (temp-dir)))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp))
(test::assert-true (str-contains tmp-dir tmp)))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix"))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix")))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix" "some-suffix"))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix"))
(test::assert-true (str-contains tmp-dir "some-suffix")))))

(with-temp (fn (tmp)
(let (tmp-dir (get-temp tmp "some-prefix" "some-suffix" 6))
(test::assert-true (str-contains tmp-dir tmp))
(test::assert-true (str-contains tmp-dir "some-prefix"))
(test::assert-true (str-contains tmp-dir "some-suffix"))
(test::assert-equal (len "some-prefix012345some-suffix") (len (fs-base tmp-dir))))))
</code></pre>
<h3 id="get-temp-file"><a class="header" href="#get-temp-file">get-temp-file</a></h3>
<p><strong>Usage:</strong> (get-temp-file ["/path/to/directory/to/use/as/base" "optional-prefix" "optional-suffix" length])</p>
<p>Returns name of file created inside temporary directory. Optionally takes a directory to use as
the parent directory of the temporary file. Also accepts an optional prefix, an optional suffix,
and an optional length for the random number of characters in the temporary files created. Defaults
to prefix of ".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains (get-temp-file) (temp-dir)))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp))
(test::assert-true (str-contains tmp-file tmp)))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix"))
(test::assert-true (str-contains tmp-file "some-prefix")))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix" "some-suffix"))
(test::assert-true (str-contains tmp-file "some-prefix"))
(test::assert-true (str-contains tmp-file "some-suffix")))))

(with-temp (fn (tmp)
(let (tmp-file (get-temp-file tmp "some-prefix" "some-suffix" 10))
(test::assert-true (str-contains tmp-file "some-prefix"))
(test::assert-true (str-contains tmp-file "some-suffix"))
(test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp-file))))))
</code></pre>
<h3 id="glob"><a class="header" href="#glob">glob</a></h3>
<p><strong>Usage:</strong> (glob /path/with/*)</p>
<p>Takes a list/varargs of globs and return the list of them expanded.</p>
<p>Example:</p>
<pre><code>(with-temp (fn (tmp)
(fclose (fopen (str tmp "/g1") :create :truncate))
(fclose (fopen (str tmp "/g2") :create :truncate))
(fclose (fopen (str tmp "/g3") :create :truncate))
(test::assert-equal [(str tmp "/g1") (str tmp "/g2") (str tmp "/g3")] (glob (str tmp "/*")))))
</code></pre>
<h3 id="read"><a class="header" href="#read">read</a></h3>
<p><strong>Usage:</strong> (read file|string end-exp?) -&gt; expression</p>
<p>Read a file or string and return the next object (symbol, string, list, etc).
Raises an error if the file or string has been read unless end-exp is provided
then returns that on the end condition.
Note: When reading a string read always starts at the beginning of the string.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate)
          test-str nil)
        (fprn tst-file "(1 2 3)(x y z)")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal '(1 2 3) (read tst-file))
        (test::assert-equal '(x y z) (read tst-file))
        (test::assert-error (read tst-file))
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal '(1 2 3) (read tst-file :done))
        (test::assert-equal '(x y z) (read tst-file :done))
        (test::assert-equal :done (read tst-file :done))
        (fclose tst-file)
        (test::assert-equal '(4 5 6) (read "(4 5 6)"))
        (set! test-str "7 8 9")
        (test::assert-equal 7 (read test-str))
        (test::assert-equal 7 (read test-str))
        (test::assert-equal '(x y z) (read "(x y z)")))))
</code></pre>
<h3 id="read-all"><a class="header" href="#read-all">read-all</a></h3>
<p><strong>Usage:</strong> (read-all file|string) -&gt; vec</p>
<p>Read a file or string and return the vector of contained expressions.  This reads the entire
file or string and will wrap it in an outer vector (always returns a vector).</p>
<p>Unlike most lisp readers this one will put loose symbols in a vector (i.e. you
enter things at the repl without the enclosing parens).</p>
<p>If the read item is empty (including a comment) then will return an empty vector.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate)
          test-str nil)
        (fprn tst-file "(1 2 3)(x y z)")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (test::assert-equal ['(1 2 3)'(x y z)] (read-all tst-file))
        (fclose tst-file)
        (test::assert-equal ['(4 5 6)] (read-all "(4 5 6)"))
        (test::assert-equal [7 8 9] (read-all "7 8 9"))
        (test::assert-equal ['(x y z)] (read-all "(x y z)"))
        (test::assert-equal [] (read-all ";(x y z)")))))
</code></pre>
<h3 id="read-line"><a class="header" href="#read-line">read-line</a></h3>
<p><strong>Usage:</strong> (read-line file) -&gt; string</p>
<p>Read a line from a file.  Returns Nil if there is nothing left to read.</p>
<p>Example:</p>
<pre><code>(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create :truncate))
        (fprn tst-file "Test Line Read Line One")
        (fpr tst-file "Test Line Read Line Two")
        (fclose tst-file)
        (set! tst-file (fopen tmp :read))
        (defer (fclose tst-file))
        (test::assert-equal "Test Line Read Line One\n" (read-line tst-file))
        (test::assert-equal "Test Line Read Line Two" (read-line tst-file)))))
</code></pre>
<h3 id="temp-dir"><a class="header" href="#temp-dir">temp-dir</a></h3>
<p><strong>Usage:</strong> (temp-dir)</p>
<p>Returns a string representing the temporary directory. See <a href="root::get-temp">get-temp</a> for higher
level temporary directory creation mechanism.</p>
<p>On Unix:
Returns the value of the TMPDIR environment variable if it is set, otherwise for non-Android it
returns /tmp. If Android, since there is no global temporary folder (it is usually allocated
per-app), it returns /data/local/tmp.</p>
<p>On Windows:
Returns the value of, in order, the TMP, TEMP, USERPROFILE environment variable if any are set and
not the empty string. Otherwise, temp_dir returns the path of the Windows directory. This behavior
is identical to that of GetTempPath, which this function uses internally.</p>
<p>Example:</p>
<pre><code>(test::assert-true (fs-dir? (temp-dir)))
</code></pre>
<h3 id="with-temp"><a class="header" href="#with-temp">with-temp</a></h3>
<p><strong>Usage:</strong> (with-temp (fn (x) (println "given temp dir:" x)) ["optional-prefix" "optional-suffix" length])</p>
<p>Takes a function that accepts a temporary directory. This directory will be recursively removed
when the provided function is finished executing. Also accepts an optional prefix, an optional
suffix, and an optional length for the random number of characters in the temporary directory
created. Defaults to prefix of ".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(with-temp (fn (tmp-dir)
    (let (tmp-file (str tmp-dir "/sl-sh-tmp-file.txt")
         a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
</code></pre>
<h3 id="with-temp-file"><a class="header" href="#with-temp-file">with-temp-file</a></h3>
<p><strong>Usage:</strong> (with-temp-file (fn (x) (println "given temp file:" x)) ["optional-prefix" "optional-suffix" length])</p>
<p>Takes a function that accepts a temporary file. This file will be removed when the provided function
is finished executing. Also accepts an optional prefix, an optional suffix, and an optional
length for the random number of characters in the temporary file created. Defaults to prefix of
".tmp", no suffix, and five random characters.</p>
<p>Example:</p>
<pre><code>(def fp nil)
(with-temp-file (fn (tmp-file)
    (let (a-file (fopen tmp-file :create :truncate))
        (test::assert-true (fs-exists? tmp-file))
        (set! fp tmp-file)
        (fclose a-file))))
(test::assert-false (nil? fp))
(test::assert-false (fs-exists? fp))

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix")))
    "some-prefix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix")))
    "some-prefix"
    "some-suffix")

(with-temp-file
    (fn (tmp)
        (test::assert-true (str-contains tmp "some-prefix"))
        (test::assert-true (str-contains tmp "some-suffix"))
        (test::assert-equal (len "some-prefix0123456789some-suffix") (len (fs-base tmp))))
    "some-prefix"
    "some-suffix"
    10)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hashmap-1"><a class="header" href="#hashmap-1">hashmap</a></h2>
<p>{{ #include section-docs/hashmap.md }}</p>
<p>List of symbols:</p>
<p><a href="src/generated-sections/hashmap.html#hash-keys">hash-keys</a>, <a href="src/generated-sections/hashmap.html#hash-remove">hash-remove!</a>, <a href="src/generated-sections/hashmap.html#make-hash">make-hash</a></p>
<h3 id="hash-keys"><a class="header" href="#hash-keys">hash-keys</a></h3>
<p><strong>Usage:</strong> (hash-keys hashmap)</p>
<p>Returns a vector of all the hashmaps keys.  The keys will be unordered.</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})
(test::assert-equal 4 (len (hash-keys tst-hash)))
(test::assert-true (in? (hash-keys tst-hash) :key1) " Test :key1")
(test::assert-true (in? (hash-keys tst-hash) 'key2) " Test key2")
(test::assert-true (in? (hash-keys tst-hash) \S) " Test S")
(test::assert-true (in? (hash-keys tst-hash) "key3") " Test key3")
(test::assert-false (in? (hash-keys tst-hash) :key4))
</code></pre>
<h3 id="hash-remove"><a class="header" href="#hash-remove">hash-remove!</a></h3>
<p><strong>Usage:</strong> (hash-remove! hashmap key)</p>
<p>Remove a key from a hashmap. This is a destructive form!</p>
<p>Example:</p>
<pre><code>(def tst-hash {:key1  "val one" 'key2 "val two" "key3" "val three" \S "val S"})
(test::assert-equal 4 (len (hash-keys tst-hash)))
(test::assert-equal "val one" tst-hash.:key1)
(test::assert-equal "val two" (get tst-hash 'key2))
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash 'key2)
(test::assert-equal 3 (len (hash-keys tst-hash)))
(test::assert-equal "val one" tst-hash.:key1)
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash :key1)
(test::assert-equal 2 (len (hash-keys tst-hash)))
(test::assert-equal "val three" (get tst-hash "key3"))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash "key3")
(test::assert-equal 1 (len (hash-keys tst-hash)))
(test::assert-equal "val S" (get tst-hash \S))
(hash-remove! tst-hash \S)
(test::assert-equal 0 (len (hash-keys tst-hash)))
</code></pre>
<h3 id="make-hash"><a class="header" href="#make-hash">make-hash</a></h3>
<p><strong>Usage:</strong> (make-hash associations?)</p>
<p>Make a new hash map.</p>
<p>If associations is provided (makes an empty map if not) then it is a list of
pairs (key . value) that populate the initial map.  Neither key nor value in the
associations will be evaluated.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="io"><a class="header" href="#io">io</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/io.html#fs-meta">fs-meta</a></p>
<h3 id="fs-meta"><a class="header" href="#fs-meta">fs-meta</a></h3>
<p><strong>Usage:</strong> (fs-meta [FILENAME]) -&gt; map</p>
<p>Returns a map of a files meta data.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="iterator"><a class="header" href="#iterator">iterator</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/iterator.html#iterenumerate">iter::enumerate</a>, <a href="src/generated-sections/iterator.html#iterfile-iter">iter::file-iter</a>, <a href="src/generated-sections/iterator.html#iterfilter">iter::filter</a>, <a href="src/generated-sections/iterator.html#iterfor">iter::for</a>, <a href="src/generated-sections/iterator.html#iteriter">iter::iter</a>, <a href="src/generated-sections/iterator.html#iteriter-or-single">iter::iter-or-single</a>, <a href="src/generated-sections/iterator.html#iteriter">iter::iter?</a>, <a href="src/generated-sections/iterator.html#iterlist-iter">iter::list-iter</a>, <a href="src/generated-sections/iterator.html#itermap">iter::map</a>, <a href="src/generated-sections/iterator.html#itermk-iter">iter::mk-iter</a>, <a href="src/generated-sections/iterator.html#iteronce-iter">iter::once-iter</a>, <a href="src/generated-sections/iterator.html#iterrange">iter::range</a>, <a href="src/generated-sections/iterator.html#iterreduce">iter::reduce</a>, <a href="src/generated-sections/iterator.html#iterrepeat-iter">iter::repeat-iter</a>, <a href="src/generated-sections/iterator.html#iterstring-iter">iter::string-iter</a>, <a href="src/generated-sections/iterator.html#itervec-iter">iter::vec-iter</a>, <a href="src/generated-sections/iterator.html#itervec-iter-pair">iter::vec-iter-pair</a>, <a href="src/generated-sections/iterator.html#itervec-iter-rev">iter::vec-iter-rev</a></p>
<h3 id="iterenumerate"><a class="header" href="#iterenumerate">iter::enumerate</a></h3>
<p><strong>Usage:</strong> (iter::enumerate iter start [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps an iterator and generates pairs of current index and value.
Index is 0 based by default, takes an optional second parameter with the start
index.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (enumerate (vec-iter [:a :b :c])))
    (let ([i v] (test-iter)) (test::assert-equal 0 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 1 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 2 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
(let (test-iter (enumerate (vec-iter [:a :b :c]) 5))
    (let ([i v] (test-iter)) (test::assert-equal 5 i) (test::assert-equal :a v))
    (let ([i v] (test-iter)) (test::assert-equal 6 i) (test::assert-equal :b v))
    (let ([i v] (test-iter)) (test::assert-equal 7 i) (test::assert-equal :c v))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="iterfile-iter"><a class="header" href="#iterfile-iter">iter::file-iter</a></h3>
<p><strong>Usage:</strong> (iter::file-iter f [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps a file.  Each call produces the next line (with
trailing newline).</p>
<p>Example:</p>
<pre><code>(import iter)
(with-temp-file (fn (file-name)
    (let (tst-file (fopen file-name :create :truncate))
        (defer (fclose tst-file))
        (fprn tst-file "line 1")
        (fprn tst-file "line 2")
        (fprn tst-file "line 3")
        (fpr tst-file "line 4"))
    (let (tst-file (fopen file-name), test-iter (file-iter tst-file))
        (defer (fclose tst-file))
        (test::assert-equal "line 1\n" (test-iter))
        (test::assert-equal "line 2\n" (test-iter))
        (test::assert-equal "line 3\n" (test-iter))
        (test::assert-equal "line 4" (test-iter))
        (test::assert-equal :*iter-empty* (test-iter)))))
</code></pre>
<h3 id="iterfilter"><a class="header" href="#iterfilter">iter::filter</a></h3>
<p><strong>Usage:</strong> (iter::filter iter lambda [SCRATCH] [SCRATCH] iter)</p>
<p>Returns a filter-iter around iter.
Iterator that applies a lambda to each element to determine if is returned- is lazy.</p>
<p>Example:</p>
<pre><code>(let (test-iter (iter::filter (iter::vec-iter [1 2 3]) (fn (x) (not (= x 2)))))
    (test::assert-equal 1 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="iterfor"><a class="header" href="#iterfor">iter::for</a></h3>
<p><strong>Usage:</strong> (iter::for bind in items body [SCRATCH] [SCRATCH] i-name actual-bind)</p>
<p>Loops over each element in an iterator.
The bind parameter is bound to the current element of items and is accessible
in body. Body is evaluated a number of times equal to the items in the iterator.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (i 0)
    (for x in (range 0 11) (set! i (+ 1 i)))
    (test::assert-equal 11 i))
(let (v [:a :b :c], iter (enumerate (vec-iter v)))
    (for [idx, val] in iter (test::assert-equal v.~idx val)))
</code></pre>
<h3 id="iteriter"><a class="header" href="#iteriter">iter::iter</a></h3>
<p><strong>Usage:</strong> (iter::iter thing)</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter '(1 2 3))))
(test::assert-true (iter? (iter [1 2 3])))
(test::assert-true (iter? (iter "abc")))
(test::assert-true (iter? (iter (iter '(1 2 3)))))
</code></pre>
<h3 id="iteriter-or-single"><a class="header" href="#iteriter-or-single">iter::iter-or-single</a></h3>
<p><strong>Usage:</strong> (iter::iter-or-single thing)</p>
<p>Return thing as an iterator if possible (if it is an iterator just return thing).
If not possible then wrap thing in a once iter and return that.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (iter-or-single '(1 2 3))))
(test::assert-true (iter? (iter-or-single [1 2 3])))
(test::assert-true (iter? (iter-or-single "abc")))
(test::assert-true (iter? (iter-or-single (iter '(1 2 3)))))
(test::assert-true (iter? (iter-or-single 1)))
(test::assert-true (iter? (iter-or-single \A)))
</code></pre>
<h3 id="iteriter-1"><a class="header" href="#iteriter-1">iter::iter?</a></h3>
<p><strong>Usage:</strong> (iter::iter? test)</p>
<p>Return true if thing is an iterator, false otherwise.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (iter? (list-iter '(1 2 3))))
(test::assert-false (iter? '(1 2 3)))
</code></pre>
<h3 id="iterlist-iter"><a class="header" href="#iterlist-iter">iter::list-iter</a></h3>
<p><strong>Usage:</strong> (iter::list-iter l [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps a list.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-list-iter (list-iter '(1 2 3)))
    (test::assert-equal 1 (test-list-iter))
    (test::assert-equal 2 (test-list-iter))
    (test::assert-equal 3 (test-list-iter))
    (test::assert-equal :*iter-empty* (test-list-iter))
    (set! test-list-iter (list-iter '()))
    (test::assert-equal :*iter-empty* (test-list-iter)))
</code></pre>
<h3 id="itermap"><a class="header" href="#itermap">iter::map</a></h3>
<p><strong>Usage:</strong> (iter::map i lambda [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that applies a lambda to each element of another iterator- is lazy.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-map-iter (map (list-iter '(1 2 3)) (fn (x) (* x 2))))
    (test::assert-equal 2 (test-map-iter))
    (test::assert-equal 4 (test-map-iter))
    (test::assert-equal 6 (test-map-iter))
    (test::assert-equal :*iter-empty* (test-map-iter)))
</code></pre>
<h3 id="itermk-iter"><a class="header" href="#itermk-iter">iter::mk-iter</a></h3>
<p><strong>Usage:</strong> (iter::mk-iter body)</p>
<p>Helper to create an iterator.  Will make sure it has the correct
property set.</p>
<p>Example:</p>
<pre><code>
</code></pre>
<h3 id="iteronce-iter"><a class="header" href="#iteronce-iter">iter::once-iter</a></h3>
<p><strong>Usage:</strong> (iter::once-iter i [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps and returns a single object once.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (once-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter))
    (set! test-iter (once-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="iterrange"><a class="header" href="#iterrange">iter::range</a></h3>
<p><strong>Usage:</strong> (iter::range start end [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that generates numbers within a range.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (range 3 6))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 4 (test-iter))
    (test::assert-equal 5 (test-iter))
    (test::assert-equal :*iter-empty* (test-iter)))
</code></pre>
<h3 id="iterreduce"><a class="header" href="#iterreduce">iter::reduce</a></h3>
<p><strong>Usage:</strong> (iter::reduce iter acc reducing-fn [SCRATCH] [SCRATCH] #<a href="src/generated-sections/SYM:367:2">SYM:367:2</a> #<a href="src/generated-sections/SYM:367:3">SYM:367:3</a> #<a href="src/generated-sections/SYM:367:3">SYM:367:3</a> [SCRATCH] val)</p>
<p>reduce is used to amalgamate an iterator and an initial value,
according to the reducing function provided. The reducing-fcn should be a function
of two arguments. In the first iteration of reduce, the init-val will be used as
the first argument to the reducing-fcn and (iter) will be used as the
second argument. For all subsequent iterations, The result from the previous
application of the reducing-fcn will be used as the first argument to the
reducing-fcn and the second argument will be the next item in the collection
when the collection is empty reduce will return the amalgamated result.</p>
<p>Example:</p>
<pre><code>(import iter)
(test::assert-true (= 15 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 0 +)))
(test::assert-true (= 16 (iter::reduce (iter::vec-iter [1 2 3 4 5]) 1 +)))
(test::assert-true (= "one hoopy frood" (iter::reduce (iter::vec-iter ["one " "hoopy " "frood"]) "" str)))
</code></pre>
<h3 id="iterrepeat-iter"><a class="header" href="#iterrepeat-iter">iter::repeat-iter</a></h3>
<p><strong>Usage:</strong> (iter::repeat-iter i [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps and returns a single object on each call.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-iter (repeat-iter 3))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (test::assert-equal 3 (test-iter))
    (set! test-iter (repeat-iter "iter"))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter))
    (test::assert-equal "iter" (test-iter)))
</code></pre>
<h3 id="iterstring-iter"><a class="header" href="#iterstring-iter">iter::string-iter</a></h3>
<p><strong>Usage:</strong> (iter::string-iter s [SCRATCH] [SCRATCH] idx slen [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps a string.  Each element is the next character.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-string-iter (string-iter "123"))
    (test::assert-equal \1 (test-string-iter))
    (test::assert-equal \2 (test-string-iter))
    (test::assert-equal \3 (test-string-iter))
    (test::assert-equal :*iter-empty* (test-string-iter)))
</code></pre>
<h3 id="itervec-iter"><a class="header" href="#itervec-iter">iter::vec-iter</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter v [SCRATCH] [SCRATCH] idx vlen [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator that wraps a vector.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter [1 2 3]))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<h3 id="itervec-iter-pair"><a class="header" href="#itervec-iter-pair">iter::vec-iter-pair</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-pair v [SCRATCH] [SCRATCH] fidx bidx [SCRATCH] [SCRATCH] iter iter)</p>
<p>Return a pair of iterators, one forward and one reverse for a vector.
The two iterators will not overlap (i.e. the forward and reverse will never
produce the same items).</p>
<p>Example:</p>
<pre><code>(import iter)
(let ([fwd-iter, rev-iter] (vec-iter-pair [1 2 3]))
    (test::assert-equal 1 (fwd-iter))
    (test::assert-equal 3 (rev-iter))
    (test::assert-equal 2 (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter))
    (test::assert-equal :*iter-empty* (fwd-iter)))
(let ([fwd-iter, rev-iter] (vec-iter-pair (vec)))
    (test::assert-equal :*iter-empty* (fwd-iter))
    (test::assert-equal :*iter-empty* (rev-iter)))
</code></pre>
<h3 id="itervec-iter-rev"><a class="header" href="#itervec-iter-rev">iter::vec-iter-rev</a></h3>
<p><strong>Usage:</strong> (iter::vec-iter-rev v [SCRATCH] [SCRATCH] idx [SCRATCH] [SCRATCH] iter)</p>
<p>Iterator produces a vector in reverse.</p>
<p>Example:</p>
<pre><code>(import iter)
(let (test-vec-iter (vec-iter-rev [1 2 3]))
    (test::assert-equal 3 (test-vec-iter))
    (test::assert-equal 2 (test-vec-iter))
    (test::assert-equal 1 (test-vec-iter))
    (test::assert-equal :*iter-empty* (test-vec-iter))
    (set! test-vec-iter (vec-iter-rev (vec)))
    (test::assert-equal :*iter-empty* (test-vec-iter)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="math"><a class="header" href="#math">math</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/math.html#">%</a>, <a href="src/generated-sections/math.html#">*</a>, <a href="src/generated-sections/math.html#">+</a>, <a href="src/generated-sections/math.html#-">-</a>, <a href="src/generated-sections/math.html#">/</a>, <a href="src/generated-sections/math.html#abs">abs</a>, <a href="src/generated-sections/math.html#rem">rem</a>, <a href="src/generated-sections/math.html#remeuclid">rem_euclid</a></p>
<h3 id="-6"><a class="header" href="#-6">%</a></h3>
<p><strong>Usage:</strong> (% int int)</p>
<p>Remainder from dividing (arg 1) by (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem_euclid</code> in Rust.
This function uses <code>rem</code> which is the same as the <code>%</code> operator in C.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem_euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (% 50 10))
(test::assert-equal 5 (% 55 10))
(test::assert-equal 1 (% 1 2))
(test::assert-equal -1 (% -10 3))
(test::assert-equal  1 (% 10 -3))
(test::assert-equal -1 (% -10 -3))

(test::assert-error (%))
(test::assert-error (% 1))
(test::assert-error (% 1 2 3))
(test::assert-error (% 1 2.0))
</code></pre>
<h3 id="-7"><a class="header" href="#-7">*</a></h3>
<p><strong>Usage:</strong> (* number*)</p>
<p>Multiply a sequence of numbers.  (*) will return 1.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (*))
(test::assert-equal 5 (* 5))
(test::assert-equal 5 (* 1 5))
(test::assert-equal 5.0 (* 1.0 5))
(test::assert-equal 7.5 (* 1.5 5))
(test::assert-equal 7.5 (* 1.5 5.0))
(test::assert-equal 15 (* 3 5))
(test::assert-equal 8 (* 1 2 4))
(test::assert-equal 16 (* 2 2 4))
(test::assert-equal 16.0 (* 2 2.0 4))
(test::assert-equal 16.0 (* 2.0 2.0 4.0))
(test::assert-equal 54.9999999999999 (* 100 0.55))
(test::assert-error (* 1 2 4 "5"))
</code></pre>
<h3 id="-8"><a class="header" href="#-8">+</a></h3>
<p><strong>Usage:</strong> (+ number*)</p>
<p>Add a sequence of numbers.  (+) will return 0.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (+))
(test::assert-equal 5 (+ 5))
(test::assert-equal 10 (+ 5 5))
(test::assert-equal 6 (+ 1 5))
(test::assert-equal 6.5 (+ 1 5.5))
(test::assert-equal 7 (+ 1 2 4))
(test::assert-error (+ 1 2 4 "5"))
</code></pre>
<h3 id="-"><a class="header" href="#-">-</a></h3>
<p><strong>Usage:</strong> (- number+)</p>
<p>Subtract a sequence of numbers.  Requires at least one number (negate if only one number).</p>
<p>Example:</p>
<pre><code>(test::assert-error (- 5 "2"))
(test::assert-equal -5 (- 5))
(test::assert-equal -5.0 (- 5.0))
(test::assert-equal -4 (- 1 5))
(test::assert-equal -4.5 (- 1 5.5))
(test::assert-equal 4 (- 10 2 4))
(test::assert-equal 4.5 (- 10 2 3.5))
</code></pre>
<h3 id="-9"><a class="header" href="#-9">/</a></h3>
<p><strong>Usage:</strong> (/ number+)</p>
<p>Divide a sequence of numbers.  Requires at least two numbers.</p>
<p>No Examples</p>
<h3 id="abs"><a class="header" href="#abs">abs</a></h3>
<p><strong>Usage:</strong> (abs arg)</p>
<p>Returns absolute value of arg.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 2 (abs 2))
(test::assert-equal 144 (abs -144))
(test::assert-equal 4.53 (abs -4.53))
(test::assert-equal 36028797018963967 (abs -36028797018963967))
</code></pre>
<h3 id="rem"><a class="header" href="#rem">rem</a></h3>
<p><strong>Usage:</strong> (rem int int)</p>
<p>Remainder from dividing (arg 1) by (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem_euclid</code> in Rust.
This function uses <code>rem</code> which is the same as the <code>%</code> operator in C.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem_euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (rem 50 10))
(test::assert-equal 5 (rem 55 10))
(test::assert-equal 1 (rem 1 2))
(test::assert-equal -1 (rem -10 3))
(test::assert-equal  1 (rem 10 -3))
(test::assert-equal -1 (rem -10 -3))

(test::assert-error (rem))
(test::assert-error (rem 1))
(test::assert-error (rem 1 2 3))
(test::assert-error (rem 1 2.0))
</code></pre>
<h3 id="rem_euclid"><a class="header" href="#rem_euclid">rem_euclid</a></h3>
<p><strong>Usage:</strong> (rem_euclid int int)</p>
<p>Least Non-negative number that can be added to a multiple of the divisor (arg 2) to get the dividend (arg 1).
The result should always be 0 &lt;= result &lt; divisor (arg 2).
Note: Remainder and Modulo are two similar mathematical operations,
called <code>rem</code> and <code>rem_euclid</code> in Rust.
With <code>rem</code>, the sign of the result is the same as the dividend (arg 1).
With <code>rem_euclid</code>, the sign of the result is always positive.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0 (rem_euclid 50 10))
(test::assert-equal 5 (rem_euclid 55 10))
(test::assert-equal 1 (rem_euclid 1 2))
(test::assert-equal 2 (rem_euclid -10 3))
(test::assert-equal 1 (rem_euclid 10 -3))
(test::assert-equal 2 (rem_euclid -10 -3))

(test::assert-error (rem_euclid))
(test::assert-error (rem_euclid 1))
(test::assert-error (rem_euclid 1 2 3))
(test::assert-error (rem_euclid 1 2.0))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pair"><a class="header" href="#pair">pair</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/pair.html#car">car</a>, <a href="src/generated-sections/pair.html#cdr">cdr</a>, <a href="src/generated-sections/pair.html#list">list</a>, <a href="src/generated-sections/pair.html#xar">xar!</a>, <a href="src/generated-sections/pair.html#xdr">xdr!</a></p>
<h3 id="car"><a class="header" href="#car">car</a></h3>
<p><strong>Usage:</strong> (car pair)</p>
<p>Return the car (first item) from a pair.  If used on a proper list this will be the first element.</p>
<p>Example:</p>
<pre><code>(def tst-pairs-two (list 'x 'y 'z))
(test::assert-equal 'x (car tst-pairs-two))
(test::assert-equal 10 (car '(10)))
(test::assert-equal 9 (car '(9 11 13)))
</code></pre>
<h3 id="cdr"><a class="header" href="#cdr">cdr</a></h3>
<p><strong>Usage:</strong> (cdr pair)</p>
<p>Return the cdr (second item) from a pair.  If used on a proper list this will be the list minus the first element.</p>
<p>Example:</p>
<pre><code>(def tst-pairs-three (list 'x 'y 'z))
(test::assert-equal '(y z) (cdr tst-pairs-three))
(test::assert-equal nil (cdr '(10)))
(test::assert-equal '(13) (cdr '(9 13)))
(test::assert-equal '(11 13) (cdr '(9 11 13)))
</code></pre>
<h3 id="list"><a class="header" href="#list">list</a></h3>
<p><strong>Usage:</strong> (list item0 item1 .. itemN)</p>
<p>Create a proper list from pairs with items 0 - N.</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(1 2 3) (list 1 2 3))
</code></pre>
<h3 id="xar"><a class="header" href="#xar">xar!</a></h3>
<p><strong>Usage:</strong> (xar! pair expression)</p>
<p>Destructive form that replaces the car (first item) in a pair with a new expression.</p>
<p>If used on a proper list will replace the first item.  Can be used on nil to
create a pair (expression . nil).</p>
<p>Example:</p>
<pre><code>(def tst-pairs-three (list 'x 'y 'z))
(test::assert-equal '(x y z) tst-pairs-three)
(test::assert-equal '(s y z) (xar! tst-pairs-three 's))
(test::assert-equal '(s y z) tst-pairs-three)
(def tst-pairs-four (list 't))
(test::assert-equal '(y) (xar! tst-pairs-four 'y))
(test::assert-equal '(y) tst-pairs-four)
</code></pre>
<h3 id="xdr"><a class="header" href="#xdr">xdr!</a></h3>
<p><strong>Usage:</strong> (xdr! pair expression)</p>
<p>Destructive form that replaces the cdr (second item) in a pair with a new expression.</p>
<p>If used on a proper list will replace everything after the first item.
Can be used on nil to create a pair (nil . expression).</p>
<p>Example:</p>
<pre><code>(def tst-pairs-five (list 'a 'b 'c))
(test::assert-equal '(a b c) tst-pairs-five)
(test::assert-equal '(a y z) (xdr! tst-pairs-five '(y z)))
(test::assert-equal '(a y z) tst-pairs-five)
(def tst-pairs-six (list 'v))
(test::assert-equal (list 'v) tst-pairs-six)
(test::assert-equal '(v . v) (xdr! tst-pairs-six 'v))
(test::assert-equal '(v . v) tst-pairs-six)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="random"><a class="header" href="#random">random</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/random.html#probool">probool</a>, <a href="src/generated-sections/random.html#random">random</a>, <a href="src/generated-sections/random.html#random-str">random-str</a></p>
<h3 id="probool"><a class="header" href="#probool">probool</a></h3>
<p><strong>Usage:</strong> (probool), (probool numerator denominator)</p>
<p>PRObability of a BOOLean.</p>
<p>If no arguments are given, returns #t 1/2 of the time, otherwise takes two
integers, numerator and denominator, and returns #t numerator/denominator of the
time. Throws an error if denominator is 0. If (&gt;= (/ numerator denominator) 1)
probool always returns true. If numerator is 0 probool always returns false.</p>
<p>Example:</p>
<pre><code>(def val0 (probool))
(test::assert-true (or (= #t val0) (= nil val0)))
(def val1 (probool 17 42))
(test::assert-true (or (= #t val1) (= nil val1)))
(test::assert-true (probool 1 1))
(test::assert-false (probool 0 42))
(test::assert-error-msg (probool 0 0) :rand "Denominator can not be zero")
(test::assert-error-msg (probool 0 0 0) :rand "Expected zero or two positive ints")
</code></pre>
<h3 id="random-1"><a class="header" href="#random-1">random</a></h3>
<p><strong>Usage:</strong> (random), (random limit)</p>
<p>Returns non-negative number less than limit and of the same type as limit.</p>
<p>Example:</p>
<pre><code>(def rand-int (random 100))
(test::assert-true (and (&gt;= rand-int 0) (&lt; rand-int 100)))
(def rand-float (random 1.0))
(test::assert-true (and (&gt;= rand-float 0.0) (&lt; rand-float 1.0)))
(test::assert-error-msg (random -1) :rand "Expected positive number")
(test::assert-error-msg (random 1 2) :rand "Expected positive number, float or int")
</code></pre>
<h3 id="random-str"><a class="header" href="#random-str">random-str</a></h3>
<p><strong>Usage:</strong> (random-str str-length [char-set])</p>
<p>Takes a positive integer, str-length, and one of :hex, :ascii, :alnum, or
a string. Returns random string of provided str-length composed of second argument,
:hex results in random hex string, :ascii results in random string of all printable
ascii characters, :alnum results in random string of all alphanumeric characters,
and providing a string results in a random string composed by sampling input.</p>
<p>Example:</p>
<pre><code>(test::assert-error-msg (random-str) :rand "Expected two arguments, length and charset")
(test::assert-error-msg (random-str 10) :rand "Expected two arguments, length and charset")
(test::assert-error-msg (random-str -1 :hex) :rand "Expected positive length")
(test::assert-error-msg (random-str 10 1) :rand "Second argument must be keyword or string")
(test::assert-error-msg (random-str 1 :hexy) :rand "Unknown symbol :hexy")
(test::assert-equal 10 (len (random-str 10 :hex)))
(test::assert-true (str-contains (random-str 42 "⚙") "⚙"))
(test::assert-equal 19 (len (random-str 19 :ascii)))
(test::assert-equal 91 (len (random-str 91 :alnum)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scripting"><a class="header" href="#scripting">scripting</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/scripting.html#run-script">run-script</a></p>
<h3 id="run-script-2"><a class="header" href="#run-script-2">run-script</a></h3>
<p><strong>Usage:</strong> (run-script path) -&gt; [last form value]</p>
<p>Read and eval a file (from path- a string).</p>
<p>Example:</p>
<pre><code>(def test-load::test-fn)
(with-temp-file (fn (tmp)
    (let (tst-file (fopen tmp :create))
        (defer (fclose tst-file))
        (fprn tst-file "(with-ns test-load")
        (fprn tst-file "    (defn test-fn () '(1 2 3)))"))
    (run-script tmp)
    (test::assert-equal '(1 2 3) (test-load::test-fn))))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sequence"><a class="header" href="#sequence">sequence</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/sequence.html#butlast">butlast</a>, <a href="src/generated-sections/sequence.html#first">first</a>, <a href="src/generated-sections/sequence.html#last">last</a>, <a href="src/generated-sections/sequence.html#rest">rest</a>, <a href="src/generated-sections/sequence.html#seq-for">seq-for</a></p>
<h3 id="butlast"><a class="header" href="#butlast">butlast</a></h3>
<p><strong>Usage:</strong> (butlast obj [SCRATCH] [SCRATCH] new-link)</p>
<p>Produces the provided list minus the last element.  Nil if the list is empty or one element.</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(1 2) (butlast '(1 2 3)))
(test::assert-equal [1 2] (butlast [1 2 3]))
(test::assert-equal nil (butlast '(1)))
(test::assert-equal [] (butlast [1]))
(test::assert-equal nil (butlast '()))
(test::assert-equal nil (butlast nil))
(test::assert-equal nil (butlast []))
</code></pre>
<h3 id="first"><a class="header" href="#first">first</a></h3>
<p><strong>Usage:</strong> (first obj)</p>
<p>Produces the first element of the provided list or vector.  Nil if the
list/vector is nil/empty.  Note this is like car that works for lists and
vectors.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 1 (first '(1 2 3)))
(test::assert-equal 1 (first [1 2 3]))
(test::assert-equal nil (first '()))
(test::assert-equal nil (first nil))
(test::assert-equal [] (first []))
</code></pre>
<h3 id="last"><a class="header" href="#last">last</a></h3>
<p><strong>Usage:</strong> (last obj [SCRATCH] [SCRATCH] last-list [SCRATCH] [SCRATCH] i)</p>
<p>Produces the last element in a list or vector.  Nil if the list/vector is empty.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 3 (last '(1 2 3)))
(test::assert-equal 3 (last [1 2 3]))
(test::assert-equal nil (last '()))
(test::assert-equal nil (last nil))
(test::assert-equal nil (last []))
</code></pre>
<h3 id="rest"><a class="header" href="#rest">rest</a></h3>
<p><strong>Usage:</strong> (rest obj)</p>
<p>Produces the provided list or vector minus the first element.  Nil if the
list/vector is nil/empty or one element.  Note this is like cdr that works for
lists and vectors.  This calls vec-slice to create a new vector when called with
a vector (i.e. is much more efficient with lists).</p>
<p>Example:</p>
<pre><code>(test::assert-equal '(2 3) (rest '(1 2 3)))
(test::assert-equal [2 3] (rest [1 2 3]))
(test::assert-equal nil (rest '(1)))
(test::assert-equal [] (rest [1]))
(test::assert-equal nil (rest '()))
(test::assert-equal nil (rest nil))
(test::assert-equal [] (rest []))
</code></pre>
<h3 id="seq-for"><a class="header" href="#seq-for">seq-for</a></h3>
<p><strong>Usage:</strong> (seq-for bind in items body [SCRATCH] [SCRATCH] lst)</p>
<p>Loops over each element in a sequence.  Simple version that works with lists and
vectors, use iterator::for in general.</p>
<p>Example:</p>
<pre><code>(def i 0)
(seq-for x in '(1 2 3 4 5 6) (set! i (+ 1 i)))
(test::assert-equal 6 i)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shell"><a class="header" href="#shell">shell</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/shell.html#args"><em>args</em></a>, <a href="src/generated-sections/shell.html#shell-exe"><em>shell-exe</em></a></p>
<h3 id="args"><a class="header" href="#args"><em>args</em></a></h3>
<p><strong>Usage:</strong> <em>args</em></p>
<p>A vector of the argumants passed to the script.
The first argument will be the name of the script.</p>
<p>No Examples</p>
<h3 id="shell-exe"><a class="header" href="#shell-exe"><em>shell-exe</em></a></h3>
<p><strong>Usage:</strong> <em>shell-exe</em></p>
<p>A string that contains the executable that is running the script.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="string-1"><a class="header" href="#string-1">string</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/string.html#str">str</a>, <a href="src/generated-sections/string.html#str-bytes">str-bytes</a>, <a href="src/generated-sections/string.html#str-cat-list">str-cat-list</a>, <a href="src/generated-sections/string.html#str-contains">str-contains</a>, <a href="src/generated-sections/string.html#str-empty">str-empty?</a>, <a href="src/generated-sections/string.html#str-lower">str-lower</a>, <a href="src/generated-sections/string.html#str-map">str-map</a>, <a href="src/generated-sections/string.html#str-push">str-push!</a>, <a href="src/generated-sections/string.html#str-replace">str-replace</a>, <a href="src/generated-sections/string.html#str-split">str-split</a>, <a href="src/generated-sections/string.html#str-splitn">str-splitn</a>, <a href="src/generated-sections/string.html#str-starts-with">str-starts-with</a>, <a href="src/generated-sections/string.html#str-sub">str-sub</a>, <a href="src/generated-sections/string.html#str-trim">str-trim</a>, <a href="src/generated-sections/string.html#str-trim">str-trim!</a>, <a href="src/generated-sections/string.html#str-upper">str-upper</a></p>
<h3 id="str"><a class="header" href="#str">str</a></h3>
<p><strong>Usage:</strong> (str arg0 ... argN) -&gt; string</p>
<p>Make a new string with its arguments.</p>
<p>Arguments will be turned into strings.  If an argument is a process then the
output of the process will be captured and put into the string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringsome" (str "string" "some"))
(test::assert-equal "string" (str "string" ""))
(test::assert-equal "string 50" (str "string" " " 50))
</code></pre>
<h3 id="str-bytes"><a class="header" href="#str-bytes">str-bytes</a></h3>
<p><strong>Usage:</strong> (str-bytes string) -&gt; int</p>
<p>Return number of bytes in a string (may be more then length).</p>
<p>Strings are utf8 so it chars and bytes may not be a one to one match.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 4 (str-bytes "Stau"))
(test::assert-equal 0 (str-bytes ""))
; Note 5 chars and 6 bytes because of the final char.
(test::assert-equal 6 (str-bytes "StauΣ"))
</code></pre>
<h3 id="str-cat-list"><a class="header" href="#str-cat-list">str-cat-list</a></h3>
<p><strong>Usage:</strong> (str-cat-list join-str sequence) -&gt; string</p>
<p>Build a string by concatenating a sequence of strings by join-str.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringxxxyyyxxxsome" (str-cat-list "xxx" ["string" "yyy" "some"]))
(test::assert-equal "string yyy some" (str-cat-list " " ["string" "yyy" "some"]))
(test::assert-equal "stringyyysome" (str-cat-list "" ["string" "yyy" "some"]))
</code></pre>
<h3 id="str-contains"><a class="header" href="#str-contains">str-contains</a></h3>
<p><strong>Usage:</strong> (str-contains string pattern) -&gt; #t/#f</p>
<p>True if string contains pattern (pattern will be converted to a string first).</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-contains "Stausomething" "Stau"))
(test::assert-false (str-contains "Stausomething" "StaU"))
(test::assert-true (str-contains "Stausomething" "some"))
(test::assert-false (str-contains "Stausomething" "Some"))
(test::assert-true (str-contains "Stausomething" "thing"))
(test::assert-false (str-contains "Stausomething" "Thing"))
(test::assert-true (str-contains "StausomeΣthing" "someΣ"))
</code></pre>
<h3 id="str-empty"><a class="header" href="#str-empty">str-empty?</a></h3>
<p><strong>Usage:</strong> (str-empty? string) -&gt; #t/#f</p>
<p>Is a string empty?  Let's find out...</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-empty? ""))
(test::assert-true (str-empty? (str-trim "   ")))
(test::assert-false (str-empty? " "))
(test::assert-false (str-empty? "string"))
</code></pre>
<h3 id="str-lower"><a class="header" href="#str-lower">str-lower</a></h3>
<p><strong>Usage:</strong> (str-lower string) -&gt; string</p>
<p>Get all lower case string from a string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stau" (str-lower "STAU"))
(test::assert-equal "stau" (str-lower "stau"))
(test::assert-equal "stau" (str-lower "Stau"))
(test::assert-equal "stau" (str-lower "StaU"))
(test::assert-equal "stau" (str-lower "sTaU"))
</code></pre>
<h3 id="str-map"><a class="header" href="#str-map">str-map</a></h3>
<p><strong>Usage:</strong> (str-map string lambda) -&gt; string</p>
<p>Make a new string by applying lambda to each char in input string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "XstringXstrX" (str-map "xstringxstrx" (fn (ch) (if (= "x" ch) "X" ch))))
(def test-str-map (str-map "xstringxstrx" (fn (ch) (if (= "x" ch) "X" ch))))
(test::assert-equal "XstringXstrX" test-str-map)
(test::assert-true (string? test-str-map))
(def test-str-map (str-map (str "xstringxstrx") (fn (ch) (if (= "x" ch) "X" ch))))
(test::assert-equal "XstringXstrX" test-str-map)
(test::assert-true (string? test-str-map))
</code></pre>
<h3 id="str-push"><a class="header" href="#str-push">str-push!</a></h3>
<p><strong>Usage:</strong> (str-push! string arg0 ... argN) -&gt; string</p>
<p>Push the args (as strings) onto the string.  This is a destructive form.</p>
<p>Arguments will be turned into strings.  Returns the string it was given.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "stringsome" (str-push! (str "string") "some"))
(def test-str-push (str "def-string"))
(test::assert-equal "def-stringsome" (str-push! test-str-push "some"))
(test::assert-equal "def-stringsome" test-str-push)
</code></pre>
<h3 id="str-replace"><a class="header" href="#str-replace">str-replace</a></h3>
<p><strong>Usage:</strong> (str-replace string old-pattern new-pattern) -&gt; string</p>
<p>Replace occurrences of second string with third in the first string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some yyy string" (str-replace "some xxx string" "xxx" "yyy"))
(test::assert-equal "some yyy string yyy" (str-replace "some xxx string xxx" "xxx" "yyy"))
(test::assert-equal "yyy some yyy string yyy" (str-replace "xxx some xxx string xxx" "xxx" "yyy"))
</code></pre>
<h3 id="str-split"><a class="header" href="#str-split">str-split</a></h3>
<p><strong>Usage:</strong> (str-split string split-pattern) -&gt; vector</p>
<p>Use a pattern to split a string (:whitespace to split on whitespace).</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["some" "yyy" "string"] (str-split "somexxxyyyxxxstring" "xxx"))
(test::assert-equal ["some" "yyy" "string" ""] (str-split "somexxxyyyxxxstringxxx" "xxx"))
(test::assert-equal ["" "some" "yyy" "string" ""] (str-split "xxxsomexxxyyyxxxstringxxx" "xxx"))
(test::assert-equal ["some" "yyy" "string"] (str-split "some yyy string" :whitespace))
(test::assert-equal ["somexxxyyyxxxstring"] (str-split "somexxxyyyxxxstring" :whitespace))
(test::assert-equal ["somexxxyyyxxxstring"] (str-split "somexxxyyyxxxstring" "zzz"))
</code></pre>
<h3 id="str-splitn"><a class="header" href="#str-splitn">str-splitn</a></h3>
<p><strong>Usage:</strong> (str-splitn n split-pattern string) -&gt; vector</p>
<p>Use a pattern to split a string with at most n items.</p>
<p>Example:</p>
<pre><code>(test::assert-equal ["some" "yyy" "string"] (str-splitn 3 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["some" "yyy" "string"] (str-splitn 4 "xxx" "somexxxyyyxxxstring"))
(test::assert-equal ["some" "yyy" "stringxxxother"] (str-splitn 3 "xxx" "somexxxyyyxxxstringxxxother"))
(test::assert-equal ["somexxxyyyxxxstringxxxother"] (str-splitn 1 "xxx" "somexxxyyyxxxstringxxxother"))
(test::assert-equal [] (str-splitn 0 "xxx" "somexxxyyyxxxstringxxxzero"))
</code></pre>
<h3 id="str-starts-with"><a class="header" href="#str-starts-with">str-starts-with</a></h3>
<p><strong>Usage:</strong> (str-starts-with string pattern) -&gt; #t/#f</p>
<p>True if string start with pattern.</p>
<p>Example:</p>
<pre><code>(test::assert-true (str-starts-with "Stausomething" "Stau"))
(test::assert-false (str-starts-with "Stausomething" "StaU"))
</code></pre>
<h3 id="str-sub"><a class="header" href="#str-sub">str-sub</a></h3>
<p><strong>Usage:</strong> (str-sub string start [length]) -&gt; string</p>
<p>Return a substring from a string given start (0 based) and optional length.
If length is 0 or not provided produces the rest of the string from start to
string end.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "string" (str-sub "stringxxxyyyxxxsome" 0 6))
(test::assert-equal "some" (str-sub "stringxxxyyyxxxsome" 15 4))
(test::assert-equal "yyy" (str-sub "stringxxxyyyxxxsome" 9 3))
(test::assert-equal "some" (str-sub "stringxxxyyyxxxsome" 15))
</code></pre>
<h3 id="str-trim"><a class="header" href="#str-trim">str-trim</a></h3>
<p><strong>Usage:</strong> (str-trim string [:right | :left]) -&gt; string</p>
<p>Trim right and/or left whitespace from string.  With no optional keywork trims both, otherwise :right
or :left specify right or left trimming.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some string" (str-trim "   some string"))
(test::assert-equal "some string" (str-trim "   some string   "))
(test::assert-equal "some string" (str-trim (str "   some string   ")))
(test::assert-equal "some string" (str-trim "some string   "))
(test::assert-equal "some string" (str-trim "some string"))

(test::assert-equal "   some string" (str-trim "   some string" :right))
(test::assert-equal "   some string" (str-trim "   some string   " :right))
(test::assert-equal "   some string" (str-trim (str "   some string   ") :right))
(test::assert-equal "some string" (str-trim "some string   " :right))
(test::assert-equal "some string" (str-trim "some string" :right))

(test::assert-equal "some string" (str-trim "   some string" :left))
(test::assert-equal "some string   " (str-trim "   some string   " :left))
(test::assert-equal "some string   " (str-trim (str "   some string   ")  :left))
(test::assert-equal "some string   " (str-trim "some string   " :left))
(test::assert-equal "some string" (str-trim "some string" :left))
</code></pre>
<h3 id="str-trim-1"><a class="header" href="#str-trim-1">str-trim!</a></h3>
<p><strong>Usage:</strong> (str-trim! string [:right | :left]) -&gt; string</p>
<p>Trim right and/or left whitespace from string in place.  With no optional keywork trims both,
otherwise :right or :left specify right or left trimming.</p>
<p>This is a destructive operation (unlike str-trim) and requires an actual non-const string as it's first
argument.  It returns this string on success.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "some string" (str-trim! (str "   some string")))
(test::assert-equal "some string" (str-trim! (str  "   some string   ")))
(test::assert-equal "some string" (str-trim! (str  (str "   some string   "))))
(test::assert-equal "some string" (str-trim! (str  "some string   ")))
(test::assert-equal "some string" (str-trim! (str  "some string")))

(test::assert-equal "   some string" (str-trim! (str  "   some string") :right))
(test::assert-equal "   some string" (str-trim! (str  "   some string   ") :right))
(test::assert-equal "   some string" (str-trim! (str  (str "   some string   "))  :right))
(test::assert-equal "some string" (str-trim! (str  "some string   ") :right))
(test::assert-equal "some string" (str-trim! (str  "some string") :right))

(test::assert-equal "some string" (str-trim! (str  "   some string") :left))
(test::assert-equal "some string   " (str-trim! (str  "   some string   ") :left))
(test::assert-equal "some string   " (str-trim! (str  (str "   some string   "))  :left))
(test::assert-equal "some string   " (str-trim! (str  "some string   ") :left))
(test::assert-equal "some string" (str-trim! (str  "some string") :left))
</code></pre>
<h3 id="str-upper"><a class="header" href="#str-upper">str-upper</a></h3>
<p><strong>Usage:</strong> (str-upper string) -&gt; string</p>
<p>Get all upper case string from a string.</p>
<p>Example:</p>
<pre><code>(test::assert-equal "STAU" (str-upper "STAU"))
(test::assert-equal "STAU" (str-upper "stau"))
(test::assert-equal "STAU" (str-upper "Stau"))
(test::assert-equal "STAU" (str-upper "StaU"))
(test::assert-equal "STAU" (str-upper "sTaU"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="system"><a class="header" href="#system">system</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/system.html#sleep">sleep</a></p>
<h3 id="sleep"><a class="header" href="#sleep">sleep</a></h3>
<p><strong>Usage:</strong> (sleep milliseconds) -&gt; nil</p>
<p>Sleep for <em>at least</em> the provided milliseconds (must be a positive integer),
otherwise function will no-op.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="test"><a class="header" href="#test">test</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/test.html#testassert-equal">test::assert-equal</a>, <a href="src/generated-sections/test.html#testassert-error">test::assert-error</a>, <a href="src/generated-sections/test.html#testassert-error-msg">test::assert-error-msg</a>, <a href="src/generated-sections/test.html#testassert-false">test::assert-false</a>, <a href="src/generated-sections/test.html#testassert-not-equal">test::assert-not-equal</a>, <a href="src/generated-sections/test.html#testassert-true">test::assert-true</a></p>
<h3 id="testassert-equal"><a class="header" href="#testassert-equal">test::assert-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-equal expected-val right-val body)</p>
<p>Asserts the two values are identical.</p>
<p>No Examples</p>
<h3 id="testassert-error"><a class="header" href="#testassert-error">test::assert-error</a></h3>
<p><strong>Usage:</strong> (test::assert-error val body)</p>
<p>Asserts the value is an error</p>
<p>No Examples</p>
<h3 id="testassert-error-msg"><a class="header" href="#testassert-error-msg">test::assert-error-msg</a></h3>
<p><strong>Usage:</strong> (test::assert-error-msg form key msg)</p>
<p>Test asserts an error is thrown with a given key and message.</p>
<p>Example:</p>
<pre><code>(test::assert-error-msg (err "error thrown") :error "error thrown")
</code></pre>
<h3 id="testassert-false"><a class="header" href="#testassert-false">test::assert-false</a></h3>
<p><strong>Usage:</strong> (test::assert-false val body)</p>
<p>Asserts the value is false</p>
<p>No Examples</p>
<h3 id="testassert-not-equal"><a class="header" href="#testassert-not-equal">test::assert-not-equal</a></h3>
<p><strong>Usage:</strong> (test::assert-not-equal expected-val right-val body)</p>
<p>Asserts the two values are not identical.</p>
<p>No Examples</p>
<h3 id="testassert-true"><a class="header" href="#testassert-true">test::assert-true</a></h3>
<p><strong>Usage:</strong> (test::assert-true val body)</p>
<p>Asserts the value is true.</p>
<p>No Examples</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="type"><a class="header" href="#type">type</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/type.html#callable">callable?</a>, <a href="src/generated-sections/type.html#char">char?</a>, <a href="src/generated-sections/type.html#err">err?</a>, <a href="src/generated-sections/type.html#io">io?</a>, <a href="src/generated-sections/type.html#list">list?</a>, <a href="src/generated-sections/type.html#nil">nil?</a>, <a href="src/generated-sections/type.html#ok">ok?</a>, <a href="src/generated-sections/type.html#pair">pair?</a>, <a href="src/generated-sections/type.html#seq">seq?</a>, <a href="src/generated-sections/type.html#str-float">str-&gt;float</a>, <a href="src/generated-sections/type.html#string">string?</a>, <a href="src/generated-sections/type.html#symbol">symbol?</a>, <a href="src/generated-sections/type.html#vec">vec?</a></p>
<h3 id="callable"><a class="header" href="#callable">callable?</a></h3>
<p><strong>Usage:</strong> (callable? v [SCRATCH] [SCRATCH] t)</p>
<p>Usage: (callable? to-test)</p>
<p>No Examples</p>
<h3 id="char-1"><a class="header" href="#char-1">char?</a></h3>
<p><strong>Usage:</strong> (char? expression)</p>
<p>True if the expression is a char, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (char? \a))
(test::assert-false (char? 1))
(test::assert-false (char? "a"))
</code></pre>
<h3 id="err-1"><a class="header" href="#err-1">err?</a></h3>
<p><strong>Usage:</strong> (err? expression)</p>
<p>True if the expression is an error, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (err? (mk-err :arr "test")))
(test::assert-false (err? nil))
</code></pre>
<h3 id="io-1"><a class="header" href="#io-1">io?</a></h3>
<p><strong>Usage:</strong> (io? expression)</p>
<p>True if the expression is an IO object (file), false otherwise.</p>
<p>Example:</p>
<pre><code>(def iotst (fopen "/tmp/iotst" :create))
(test::assert-true (io? iotst))
(test::assert-false (io? 1))
(test::assert-false (io? '(1 2 3)))
(test::assert-false (io? (list)))
</code></pre>
<h3 id="list-1"><a class="header" href="#list-1">list?</a></h3>
<p><strong>Usage:</strong> (list? expression)</p>
<p>True if the expression is a list, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (list? '(1 2 3)) "reader macro")
(test::assert-true (list? (list 1 2 3)) "list")
(test::assert-false (list? 1))
(test::assert-false (list? [1 2 3]))
(test::assert-false (list? []))
(test::assert-false (list? '(1 . 2)))
</code></pre>
<h3 id="nil"><a class="header" href="#nil">nil?</a></h3>
<p><strong>Usage:</strong> (nil? v)</p>
<p>True if the expression is nil, false otherwise</p>
<p>Example:</p>
<pre><code>(test::assert-true (nil? ()))
(test::assert-true (nil? '()))
(test::assert-true (nil? nil))
(test::assert-true (nil? (list)))
(test::assert-false (nil? #f))
</code></pre>
<h3 id="ok"><a class="header" href="#ok">ok?</a></h3>
<p><strong>Usage:</strong> (ok? expression)</p>
<p>True if the expression is NOT an error, false if it is an error.</p>
<p>Example:</p>
<pre><code>(test::assert-false (ok? (mk-err :arr "test")))
(test::assert-true (ok? nil))
</code></pre>
<h3 id="pair-1"><a class="header" href="#pair-1">pair?</a></h3>
<p><strong>Usage:</strong> (pair? expression)</p>
<p>True if the expression is a pair, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (pair? '(1 . 2)) "reader macro")
(test::assert-true (pair? (cons 1 2)) "cons")
(test::assert-true (pair? '(1 2)))
(test::assert-false (pair? 1))
(test::assert-false (pair? [1 2 3]))
(test::assert-false (pair? (vec)))
</code></pre>
<h3 id="seq"><a class="header" href="#seq">seq?</a></h3>
<p><strong>Usage:</strong> (seq? expression)</p>
<p>True if expression is a list or vector, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (seq? '(1 2 3)))
(test::assert-true (seq? [1 2 3]))
(test::assert-true (seq? []))
(test::assert-false (seq? "aaa"))
(test::assert-false (seq? 1))
</code></pre>
<h3 id="str-float"><a class="header" href="#str-float">str-&gt;float</a></h3>
<p><strong>Usage:</strong> (str-&gt;float string) -&gt; float</p>
<p>If string is a valid representation of a float return that float.  Error if not.</p>
<p>Example:</p>
<pre><code>(test::assert-equal 0.0 (str-&gt;float "0"))
(test::assert-equal 10.0 (str-&gt;float "10.0"))
(test::assert-equal 10.5 (str-&gt;float "10.5"))
(test::assert-equal 101.0 (str-&gt;float "101"))
(test::assert-equal -101.95 (str-&gt;float "-101.95"))
(test::assert-error (str-&gt;float "not int"))
(test::assert-error (str-&gt;float "--10"))
</code></pre>
<h3 id="string-2"><a class="header" href="#string-2">string?</a></h3>
<p><strong>Usage:</strong> (string? expression)</p>
<p>True if the expression is a string, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (string? "string"))
(test::assert-false (string? 1))
</code></pre>
<h3 id="symbol"><a class="header" href="#symbol">symbol?</a></h3>
<p><strong>Usage:</strong> (symbol? expression)</p>
<p>True if the expression is a symbol, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (symbol? 'symbol))
(test::assert-false (symbol? 1))
</code></pre>
<h3 id="vec"><a class="header" href="#vec">vec?</a></h3>
<p><strong>Usage:</strong> (vec? expression)</p>
<p>True if the expression is a vector, false otherwise.</p>
<p>Example:</p>
<pre><code>(test::assert-true (vec? [1 2 3]) "reader macro")
(test::assert-true (vec? (make-vec)) "make-vec")
(test::assert-true (vec? (vec 1 2 3)) "vec")
(test::assert-false (vec? 1))
(test::assert-false (vec? '(1 2 3)))
(test::assert-false (vec? (list)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="vector-1"><a class="header" href="#vector-1">vector</a></h2>
<p>List of symbols:</p>
<p><a href="src/generated-sections/vector.html#make-vec">make-vec</a>, <a href="src/generated-sections/vector.html#vec">vec</a>, <a href="src/generated-sections/vector.html#vec-list">vec-&gt;list</a>, <a href="src/generated-sections/vector.html#vec-pop">vec-pop!</a>, <a href="src/generated-sections/vector.html#vec-push">vec-push!</a>, <a href="src/generated-sections/vector.html#vec-slice">vec-slice</a></p>
<h3 id="make-vec"><a class="header" href="#make-vec">make-vec</a></h3>
<p><strong>Usage:</strong> (make-vec capacity default)</p>
<p>Make a new vector with capacity and default item(s).</p>
<p>Example:</p>
<pre><code>(test::assert-equal [] (make-vec))
(test::assert-equal ['x 'x 'x] (make-vec 3 'x))
(test::assert-equal [nil nil nil nil nil] (make-vec 5 nil))
(test::assert-equal [] (make-vec 5))
</code></pre>
<h3 id="vec-1"><a class="header" href="#vec-1">vec</a></h3>
<p><strong>Usage:</strong> (vec item1 item2 .. itemN)</p>
<p>Make a new vector with items.</p>
<p>Example:</p>
<pre><code>(test::assert-equal [] (vec))
(test::assert-equal [1 2 3] (vec 1 2 3))
</code></pre>
<h3 id="vec-list"><a class="header" href="#vec-list">vec-&gt;list</a></h3>
<p><strong>Usage:</strong> (vec-&gt;list vector)</p>
<p>Convert a vector to a list.</p>
<p>No Examples</p>
<h3 id="vec-pop"><a class="header" href="#vec-pop">vec-pop!</a></h3>
<p><strong>Usage:</strong> (vec-pop! vector) -&gt; object</p>
<p>Pops the last object off of the end of the vector.  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-pop-vec (vec 1 2 3))
(test::assert-equal 3 (vec-pop! test-pop-vec))
(test::assert-equal [1 2] test-pop-vec)
(test::assert-equal 2 (vec-pop! test-pop-vec))
(test::assert-equal [1] test-pop-vec)
(test::assert-equal 1 (vec-pop! test-pop-vec))
(test::assert-equal [] test-pop-vec)
</code></pre>
<h3 id="vec-push"><a class="header" href="#vec-push">vec-push!</a></h3>
<p><strong>Usage:</strong> (vec-push! vector object) -&gt; vector</p>
<p>Pushes the provided object onto the end of the vector.  This is destructive!</p>
<p>Example:</p>
<pre><code>(def test-push-vec (vec))
(test::assert-equal [1] (vec-push! test-push-vec 1))
(test::assert-equal [1] test-push-vec)
(test::assert-equal [1 2] (vec-push! test-push-vec 2))
(test::assert-equal [1 2] test-push-vec)
(test::assert-equal [1 2 3] (vec-push! test-push-vec 3))
(test::assert-equal [1 2 3] test-push-vec)
</code></pre>
<h3 id="vec-slice"><a class="header" href="#vec-slice">vec-slice</a></h3>
<p><strong>Usage:</strong> (vec-slice vector start end)</p>
<p>Returns a slice of a vector (0 based indexes, end is exclusive).</p>
<p>Example:</p>
<pre><code>(test::assert-equal [5 6] (vec-slice [1 2 3 4 5 6] 4 6))
(test::assert-equal [1 2 3] (vec-slice [1 2 3 4 5 6] 0 3))
(test::assert-equal [3 4 5] (vec-slice [1 2 3 4 5 6] 2 5))
(test::assert-equal [3 4 5 6] (vec-slice [1 2 3 4 5 6] 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking-function-parity-between-sl-sh-and-slosh"><a class="header" href="#tracking-function-parity-between-sl-sh-and-slosh">tracking function Parity Between sl-sh and slosh</a></h1>
<h2 id="forms-yet-to-be-implemented-325"><a class="header" href="#forms-yet-to-be-implemented-325">Forms yet to be implemented: 325</a></h2>
<h2 id="forms-implemented-or-skipped-196"><a class="header" href="#forms-implemented-or-skipped-196">Forms implemented or skipped: 196</a></h2>
<div class="table-wrapper"><table><thead><tr><th>?</th><th>Slosh Form</th><th>Notes</th></tr></thead><tbody>
<tr><td>✅</td><td><code>%                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>*                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>*active-ns*                     </code></td><td>Renamed to: <code>*ns*</code></td></tr>
<tr><td>✅</td><td><code>*bg-black*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-blue*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-cyan*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-default*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-green*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-magenta*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-red*                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-white*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*bg-yellow*                     </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*collection-src*                </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*core-src*                      </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*euid*                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>*euler*                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-black*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-blue*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-cyan*                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-default*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-green*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-magenta*                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-red*                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-white*                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>*fg-yellow*                     </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*getopts-log*                   </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*getopts-src*                   </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*iterator-src*                  </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>*last-command*                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>*last-status*                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>*lib-src*                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>*load-path*                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>*ns*                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>*ns-exports*                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>*pi*                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>*read-table*                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>*read-table-terminal*           </code></td><td></td></tr>
<tr><td>❌</td><td><code>*repl-settings*                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>*run-script*                    </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*seq-src*                       </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*shell-read-src*                </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*shell-src*                     </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*slsh-std-src*                  </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*slshrc-src*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>*std-lib-exported-syms-hash*    </code></td><td></td></tr>
<tr><td>❌</td><td><code>*std-lib-namespaces*            </code></td><td></td></tr>
<tr><td>❌</td><td><code>*std-lib-syms-hash*             </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stderr*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stdin*                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>*stdout*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>*string-read-table*             </code></td><td></td></tr>
<tr><td>☑️</td><td><code>*struct-src*                    </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>*test-src*                      </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>*uid*                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>=+                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>-                               </code></td><td></td></tr>
<tr><td>❌</td><td><code>-&gt;                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>-&gt;&gt;                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>/                               </code></td><td></td></tr>
<tr><td>❌</td><td><code>2pow                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>&lt;                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&lt;=                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>=                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&gt;                               </code></td><td></td></tr>
<tr><td>✅</td><td><code>&gt;=                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>^ns-stack-xyz^                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>__prompt                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>abs                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>alias                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>alias?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>and                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>and-let*                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>append                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>append-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>append-to!                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>apply                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>apply-defaults                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>arccos                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>arcsin                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>arctan                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>args                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>arity-zero-can-not-be-required  </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-equal                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-error                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-error-msg                </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-false                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-includes                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-not-equal                </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-not-includes             </code></td><td></td></tr>
<tr><td>❌</td><td><code>assert-true                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>back-quote                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>bg                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>bg-color-rgb                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>block                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>boolean?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>builtin?                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>butlast                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>caaar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>caadr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>caar                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadddr                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>caddr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cadr                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>callable?                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>car                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>cd                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdaar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdadr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdar                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>cddar                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cdddr                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>cddr                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>cdr                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>ceil                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain-and                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>chain-when                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>char-&gt;int                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-lower                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-upper                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>char-whitespace?                </code></td><td></td></tr>
<tr><td>✅</td><td><code>char?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>check                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>check-custom                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>clear-dirs                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>close                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>codepoints                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>collate-fs-changes              </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-copy                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-str                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>collect-vec                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>cond                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>consume-comment                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>consume-whitespace              </code></td><td></td></tr>
<tr><td>❌</td><td><code>cos                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>dec!                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>def                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>def?                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>defmacro                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>defn                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>defstruct                       </code></td><td>Will consider other implementations if struct-like functionality if desired.</td></tr>
<tr><td>☑️</td><td><code>deftrait                        </code></td><td>Will consider other implementations if trait-like functionality is desired.</td></tr>
<tr><td>❌</td><td><code>dirs                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>do                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>do-unstr                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>doc                             </code></td><td></td></tr>
<tr><td>☑️</td><td><code>doc-raw                         </code></td><td>Possible now with command: (get-prop 'symbol :doc-string)</td></tr>
<tr><td>✅</td><td><code>dotimes                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>dotimes-i                       </code></td><td></td></tr>
<tr><td>☑️</td><td><code>double-ended-iter?              </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>double-ended-iterator           </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>✅</td><td><code>dyn                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>empty-seq?                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>empty?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>enforce-constrains              </code></td><td></td></tr>
<tr><td>❌</td><td><code>epoch                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>eprint                          </code></td><td>Renamed to: <code>epr</code></td></tr>
<tr><td>✅</td><td><code>eprintln                        </code></td><td>Renamed to: <code>eprn</code></td></tr>
<tr><td>✅</td><td><code>err                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;&gt;                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>err&gt;null                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>error-stack-off                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>error-stack-on                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>eval                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>exit                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>exp                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-brace                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-dollar                   </code></td><td></td></tr>
<tr><td>✅</td><td><code>expand-macro                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-macro-all                </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-macro1                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>expand-tilde                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>export                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>false?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>falsey?                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>fc                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>fg                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>fg-color-rgb                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>file-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>file?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>filter                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>filter-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>find-symbol                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>first                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>first-quartile                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>fix-one-arg-bindings            </code></td><td></td></tr>
<tr><td>❌</td><td><code>flatten-args                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>float-&gt;int                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>float?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>floor                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>flush                           </code></td><td>Renamed to: <code>fflush</code></td></tr>
<tr><td>✅</td><td><code>fn                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>fn-to-predicate                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>fncall                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>for                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>for-i                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>fork                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>format                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>fract                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-accessed                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-base                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-crawl                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-dir?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-exists?                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-file?                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-len                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-modified                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>fs-notify                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-parent                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-rm                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>fs-same?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>func?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>gensym                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-arity                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-dirs                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-env                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-error                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-home                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-next-params                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>get-pid                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-rgb-seq                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-temp                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>get-temp-file                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>get_pwd                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-bad-first-arg           </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-bad-option-arity        </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-help                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-help--options-map-is-map</code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-illegal-option          </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-invalid-type-function   </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-options-map-is-map      </code></td><td></td></tr>
<tr><td>❌</td><td><code>getopts-type-error-message      </code></td><td></td></tr>
<tr><td>✅</td><td><code>glob                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>handle-last-command             </code></td><td></td></tr>
<tr><td>❌</td><td><code>handle-process                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash-clear!                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash-get                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash-haskey                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>hash-keys                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>hash-remove!                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash-set!                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>hash?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-context                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-empty?                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-length                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-nth                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-push                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>history-push-throwaway          </code></td><td></td></tr>
<tr><td>✅</td><td><code>identity                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>if                              </code></td><td></td></tr>
<tr><td>✅</td><td><code>import                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>in?                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>inc!                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>int-&gt;float                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>int?                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>interleave                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>interleave-iter                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>intern-stats                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-getopts-option-string        </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-multi-char-arg               </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-multi-single-char-args       </code></td><td></td></tr>
<tr><td>❌</td><td><code>is-single-char-arg              </code></td><td></td></tr>
<tr><td>❌</td><td><code>iter                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>iter-or-single                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>iter?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>iterator                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>jobs                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>join                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>lambda?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>last                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>len0?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>len&gt;0?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>length                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>let                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>let*                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>let-env                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>list                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>list-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>list-vec?                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>list?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>lists=                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>lne                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>load                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>log                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>log2                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>logger                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>loop                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>macro                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>macro?                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>make-hash                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>make-hash-with-keys             </code></td><td></td></tr>
<tr><td>❌</td><td><code>make-regex                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>make-vec                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>map                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>map-iter                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>match                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>max                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>maybe-docstring?                </code></td><td></td></tr>
<tr><td>❌</td><td><code>maybe-glob?                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>mean                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>median                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>meld                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>meld-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-add-tags                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-column-no                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-file-name                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-line-no                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>meta-tag?                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>method                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>min                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>mkli                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>mode                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>next!                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>nil?                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>non-empty-seq?                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>none?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>not                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>ns-auto-export                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>ns-create                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>ns-enter                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>ns-exists?                      </code></td><td></td></tr>
<tr><td>☑️</td><td><code>ns-export                       </code></td><td>Everything in slosh is exported by default.</td></tr>
<tr><td>✅</td><td><code>ns-import                       </code></td><td>Renamed to: <code>import</code></td></tr>
<tr><td>❌</td><td><code>ns-list                         </code></td><td></td></tr>
<tr><td>☑️</td><td><code>ns-pop                          </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>☑️</td><td><code>ns-push                         </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>ns-symbols                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>nsubstitute!                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>nth                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>null                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>nyi                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>occurs                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>open                            </code></td><td>Renamed to: <code>fopen</code></td></tr>
<tr><td>✅</td><td><code>or                              </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;&gt;                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>out-err&gt;null                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;&gt;                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>out&gt;null                        </code></td><td></td></tr>
<tr><td>☑️</td><td><code>pair=                           </code></td><td>Do not need separate equals specifier for pair.</td></tr>
<tr><td>✅</td><td><code>pair?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>path_list_trunc                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>pid                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>pipe                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>pipe-err                        </code></td><td>Not necessary in slosh.</td></tr>
<tr><td>❌</td><td><code>popd                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>pow                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>print                           </code></td><td>Renamed to: <code>pr</code></td></tr>
<tr><td>☑️</td><td><code>print-error                     </code></td><td>Now one drops in to the debugger when an error occurs.</td></tr>
<tr><td>✅</td><td><code>println                         </code></td><td>Renamed to: <code>prn</code></td></tr>
<tr><td>✅</td><td><code>probool                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>process?                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>prompt                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>pushd                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>qsort                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>quote                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>random                          </code></td><td></td></tr>
<tr><td>✅</td><td><code>random-str                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>range                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>range-iter                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-color                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-find                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-find-all                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-match                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>re-replace                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>read                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>read-all                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>read-line                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-list                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-string                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-var                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>read-var-bracket                </code></td><td></td></tr>
<tr><td>❌</td><td><code>reader-macro-dot                </code></td><td></td></tr>
<tr><td>❌</td><td><code>reap-jobs                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>recur                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&amp;&gt;                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&amp;&gt;&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir2&gt;                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir2&gt;&gt;                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&gt;                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>redir&gt;&gt;                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>reduce                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>reduce-times                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>ref                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>regex?                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>register-alias                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>repeat                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>repeat-iter                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl-eof                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>repl-line                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>required-argument               </code></td><td></td></tr>
<tr><td>✅</td><td><code>rest                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>return-from                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>reverse                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>reverse-iter                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>rm-esc                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>round                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-bg-first                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-bg-prep-args                </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-example                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>run-ns-example                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>seq-for                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>seq?                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>set!                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>set-dirs-max                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>set_prompt_tail                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>setnth!                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>setup-chainer                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>shell-read                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>shell-read-int                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>sin                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>single-iter                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>sleep                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>slice                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>slice-iter                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>some?                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>sqrt                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>std-dev                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-&gt;float                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-&gt;int                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-append                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-bytes                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-cat-list                    </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-clear!                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-contains                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-empty?                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-empty?                 </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-next!                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-peek                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-iter-start                  </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-lower                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-ltrim                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-map                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-nth                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-push!                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-replace                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-rsplit                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-rsplitn                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>str-rtrim                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-split                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-splitn                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-starts-with                 </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-sub                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-trim                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>str-upper                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>string-iter                     </code></td><td></td></tr>
<tr><td>✅</td><td><code>string?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>substitute                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>summary-stats                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>supported-types-map             </code></td><td></td></tr>
<tr><td>❌</td><td><code>sym                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>sym-&gt;str                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>symbol?                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>syntax-off                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>syntax-on                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>sys-apply                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>sys-command?                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>syscall                         </code></td><td>Renamed to: <code>sh</code></td></tr>
<tr><td>❌</td><td><code>take                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>take-iter                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>tan                             </code></td><td></td></tr>
<tr><td>✅</td><td><code>temp-dir                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>third-quartile                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>time                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>timer                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>to-degrees                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>to-radians                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-default-color               </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-invalid-color               </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-slsh-fcn-color              </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-slsh-form-color             </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-string-color                </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-sys-alias-color             </code></td><td></td></tr>
<tr><td>✅</td><td><code>tok-sys-command-color           </code></td><td></td></tr>
<tr><td>❌</td><td><code>token-delim                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>true?                           </code></td><td></td></tr>
<tr><td>✅</td><td><code>type                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>umask                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>unalias                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>undef                           </code></td><td></td></tr>
<tr><td>❌</td><td><code>unexport                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>unregister-alias                </code></td><td></td></tr>
<tr><td>❌</td><td><code>unwind-protect                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>valid-first-arg?                </code></td><td></td></tr>
<tr><td>❌</td><td><code>values                          </code></td><td></td></tr>
<tr><td>❌</td><td><code>values-length                   </code></td><td></td></tr>
<tr><td>❌</td><td><code>values-nth                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>values?                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>var                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>var-or-env                      </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec                             </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-clear!                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-empty?                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-insert!                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-iter                        </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-nth                         </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-pop!                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-push!                       </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-remove!                     </code></td><td></td></tr>
<tr><td>❌</td><td><code>vec-set!                        </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec-slice                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>vec?                            </code></td><td></td></tr>
<tr><td>☑️</td><td><code>verify-all-options-valid        </code></td><td>Leftover from getopts implementation.</td></tr>
<tr><td>☑️</td><td><code>verify-arity                    </code></td><td>Leftover from getopts implementation.</td></tr>
<tr><td>✅</td><td><code>version                         </code></td><td></td></tr>
<tr><td>❌</td><td><code>wait                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>when                            </code></td><td></td></tr>
<tr><td>❌</td><td><code>with-padding                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>with-temp                       </code></td><td></td></tr>
<tr><td>✅</td><td><code>with-temp-file                  </code></td><td></td></tr>
<tr><td>❌</td><td><code>write-line                      </code></td><td></td></tr>
<tr><td>❌</td><td><code>write-string                    </code></td><td></td></tr>
<tr><td>✅</td><td><code>xar!                            </code></td><td></td></tr>
<tr><td>✅</td><td><code>xdr!                            </code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p>[Slosh Rust Docs]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[All Rust Docs]</p>
<div style="break-before: page; page-break-before: always;"></div><p>[Legacy sl-sh Documentation]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
